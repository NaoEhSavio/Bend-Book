<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="Guide/Start.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Guide/About.html"><strong aria-hidden="true">1.1.</strong> About bend</a></li><li class="chapter-item expanded "><a href="Guide/Terminal.html"><strong aria-hidden="true">1.2.</strong> Terminal</a></li><li class="chapter-item expanded "><a href="Guide/Instalation.html"><strong aria-hidden="true">1.3.</strong> Installation</a></li><li class="chapter-item expanded "><a href="Guide/IDE.html"><strong aria-hidden="true">1.4.</strong> IDE</a></li><li class="chapter-item expanded "><a href="Guide/HelloWord.html"><strong aria-hidden="true">1.5.</strong> Hello World!</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.6.</strong> BPM</div></li></ol></li><li class="chapter-item expanded "><a href="Learn.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Logic in Bend</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/01_Logic/01_comments.html"><strong aria-hidden="true">3.1.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Book/01_Logic/02_numbers.html"><strong aria-hidden="true">3.2.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="Book/01_Logic/03_variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="Book/01_Logic/04_tail_recursion.html"><strong aria-hidden="true">3.4.</strong> Recursion</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Data Structures</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/02_Data_Structures/01_type.html"><strong aria-hidden="true">4.1.</strong> type</a></li><li class="chapter-item expanded "><a href="Book/02_Data_Structures/02_object.html"><strong aria-hidden="true">4.2.</strong> object</a></li><li class="chapter-item expanded "><a href="Book/02_Data_Structures/03_tuple.html"><strong aria-hidden="true">4.3.</strong> tuple</a></li><li class="chapter-item expanded "><a href="Book/02_Data_Structures/04_list.html"><strong aria-hidden="true">4.4.</strong> list</a></li><li class="chapter-item expanded "><a href="Book/02_Data_Structures/05_map.html"><strong aria-hidden="true">4.5.</strong> map</a></li><li class="chapter-item expanded "><a href="Book/02_Data_Structures/06_tree.html"><strong aria-hidden="true">4.6.</strong> tree</a></li><li class="chapter-item expanded "><a href="Book/02_Data_Structures/07_matrix.html"><strong aria-hidden="true">4.7.</strong> matrix</a></li><li class="chapter-item expanded "><a href="Book/02_Data_Structures/08_graph.html"><strong aria-hidden="true">4.8.</strong> graph</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Function Structures</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/03_Function_Structures/01_functions.html"><strong aria-hidden="true">5.1.</strong> functions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Patterns and Matching</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/04_Patterns_and_Matching/01_if.html"><strong aria-hidden="true">6.1.</strong> if</a></li><li class="chapter-item expanded "><a href="Book/04_Patterns_and_Matching/02_switch.html"><strong aria-hidden="true">6.2.</strong> switch</a></li><li class="chapter-item expanded "><a href="Book/04_Patterns_and_Matching/03_match.html"><strong aria-hidden="true">6.3.</strong> match</a></li><li class="chapter-item expanded "><a href="Book/04_Patterns_and_Matching/04_fold.html"><strong aria-hidden="true">6.4.</strong> fold</a></li><li class="chapter-item expanded "><a href="Book/04_Patterns_and_Matching/05_bend.html"><strong aria-hidden="true">6.5.</strong> bend</a></li><li class="chapter-item expanded "><a href="Book/04_Patterns_and_Matching/06_open.html"><strong aria-hidden="true">6.6.</strong> open</a></li><li class="chapter-item expanded "><a href="Book/04_Patterns_and_Matching/07_with.html"><strong aria-hidden="true">6.7.</strong> with block</a></li></ol></li><li class="chapter-item expanded "><a href="Book/05_IO/00_IO.html"><strong aria-hidden="true">7.</strong> IO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/05_IO/01_Input_and_Output.html"><strong aria-hidden="true">7.1.</strong> Input_and_Output</a></li><li class="chapter-item expanded "><a href="Book/05_IO/02_Time_and_sleep.html"><strong aria-hidden="true">7.2.</strong> Time_and_sleep</a></li><li class="chapter-item expanded "><a href="Book/05_IO/03_File_IO.html"><strong aria-hidden="true">7.3.</strong> File_IO</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Language Features</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/06_Functional_Language_Features/01_haskell/01_syntax.html"><strong aria-hidden="true">8.1.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="Book/06_Functional_Language_Features/02_lambda/01_lambda.html"><strong aria-hidden="true">8.2.</strong> Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/06_Functional_Language_Features/02_lambda/02_scopeless_lambdas.html"><strong aria-hidden="true">8.2.1.</strong> scopeless lambdas</a></li></ol></li><li class="chapter-item expanded "><a href="Book/06_Functional_Language_Features/03_Sup_and_dups/01_sup_and_dups.html"><strong aria-hidden="true">8.3.</strong> Dups and Sups</a></li></ol></li><li class="chapter-item expanded "><a href="Book/07_Concurrency/parallel.html"><strong aria-hidden="true">9.</strong> Concurrency</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><div>Contributors</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let’s start your Bend journey! There’s a lot to learn, but every journey starts somewhere. In this chapter, we’ll discuss:</p>
<ul>
<li>Learn the terminal and how to use its commands</li>
<li>Know a little about <code>Bend</code></li>
<li>Installing <code>Bend</code> on <code>Linux</code> and <code>macOS</code></li>
<li>Writing a program that prints Hello, world!</li>
<li>Using BPM, Bend’s package manager and build system</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-bend"><a class="header" href="#about-bend">About Bend</a></h1>
<p>Welcome to Bend, an innovative and versatile programming language designed to empower developers with simplicity and efficiency. Bend aims to blend the best features of modern programming paradigms with an intuitive syntax that makes coding a delightful experience.</p>
<h2 id="what-is-bend"><a class="header" href="#what-is-bend">What is Bend?</a></h2>
<p>Bend is a high-level programming language developed by HigherOrderCO. It is designed with a focus on readability, performance, and ease of use. Bend allows developers to write clean and maintainable code while leveraging powerful abstractions to manage complexity.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Intuitive Syntax</strong>: Bend's syntax is designed to be straightforward and easy to read, making it accessible to both beginners and experienced programmers.</li>
<li><strong>High Performance</strong>: Bend is built to be fast and efficient, ensuring that your applications run smoothly and respond quickly.</li>
<li><strong>Modern Paradigms</strong>: While Bend incorporates features from modern programming paradigms, it presents them in a gradual and approachable manner.</li>
</ul>
<h2 id="why-choose-bend"><a class="header" href="#why-choose-bend">Why Choose Bend?</a></h2>
<ul>
<li><strong>Productivity</strong>: Bend's clean syntax and powerful abstractions enable you to write less code and achieve more, boosting your productivity.</li>
<li><strong>Community</strong>: Join a growing community of Bend enthusiasts and contributors who are passionate about advancing the language and sharing their knowledge.</li>
<li><strong>Open Source</strong>: Bend is open-source, and we welcome contributions from developers around the world. You can find the Bend source code and contribute to its development on our <a href="https://github.com/HigherOrderCO/Bend">GitHub repository</a>.</li>
</ul>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>Ready to dive into Bend? Our comprehensive documentation and tutorials will guide you through the installation process, basic concepts, and advanced features. Whether you are building web applications, data analysis tools, or system utilities, Bend has the versatility and performance to help you succeed.</p>
<p>Thank you for choosing Bend. We look forward to seeing what you create!</p>
<p>Happy coding!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal"><a class="header" href="#terminal">Terminal</a></h1>
<p>The exploration is not terminating, we are just getting started.</p>
<p>If you already know how to work with terminals, skip to the <a href="Guide/./Installation.html">Installation</a> step.</p>
<h2 id="what-is-a-terminal"><a class="header" href="#what-is-a-terminal">What is a Terminal</a></h2>
<p>A terminal can be described as an interface for users to communicate with the computer.</p>
<p>They are our command-line interface, a place where we type commands and the computer process it.</p>
<p>You can customize your terminal the way you want and feel most comfortable with.</p>
<p>Command-lines in a terminal follow a "left to right" hierarchy, the left side always come first and the computer interprets them in this order.</p>
<p>Before explaining terminal commands to you, there is a very important command that you need to understand, the sudo command. sudo is the abbreviation of "super user do" that, when used, allows a user to get privileges of another user (usually the super user) to securely perform specific tasks within the system in a administrator controllable manner. You will need to use the sudo command in a lot of cases.</p>
<h2 id="terminal-commands"><a class="header" href="#terminal-commands">Terminal Commands</a></h2>
<p>When double clicking a folder in order to open it, your computer basically understand and does the <code>cd folder</code> command; the same happens when renaming a file, the computer will understand it as using the command <code>mv oldfilename.bend</code> <code>newfilename.bend</code>.</p>
<p>The terminal is simply a command line where you type those commands directly to your computer. As this is extensively used in this guide book, it is recommended that you get familiar with this by playing with the commands below (just be careful with some of them, like <code>rm</code>).</p>
<p>For now, let's take a look at a few of the most used terminal commands. Even though everything that is used in this guide will be explained, if you want to dive deeper into terminal commands, look up to this this <a href="https://www.git-tower.com/blog/command-line-cheat-sheet/">link</a>.</p>
<h3 id="list-of-commands"><a class="header" href="#list-of-commands">List of Commands</a></h3>
<pre><code class="language-md">cd
ls
mkdir
rm
mv
touch
clear
</code></pre>
<h4 id="directory-related-commands"><a class="header" href="#directory-related-commands">Directory related commands</a></h4>
<ul>
<li>The command <code>cd</code> stands for "Change Directory", and it navigates through them.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>cd</code></td><td style="text-align: left"><code>Home</code>: Goes back to your base folder (main folder).</td></tr>
<tr><td style="text-align: left"><code>cd ..</code></td><td style="text-align: left"><code>Back</code>: Moves to the previous folder.</td></tr>
<tr><td style="text-align: left"><code>cd 'folderName'</code></td><td style="text-align: left"><code>Through Files</code>: Will take you to that folder specified.</td></tr>
</tbody></table>
</div>
<ul>
<li>The command <code>ls</code> stands for "List Files", and lists the content of the current folder.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ls</code></td><td style="text-align: left"><code>Listing</code>: Will show you a list of the files and folders </br> in the current folder that you are in.</td></tr>
<tr><td style="text-align: left"><code>ls -la</code></td><td style="text-align: left"><code>Deeper Listing</code>: Will show a more detailed version of </br> the ls command, with it's hidden files or folders.</td></tr>
</tbody></table>
</div>
<ul>
<li>The command <code>mkdir</code> , that stands for "Make Directory", creates a new folder.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command              </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>mkdir folderName</code></td><td style="text-align: left"><code>Creating</code>: Works by creating a folder with the specified</br>  name. For example:</br><code>mkdir exampleFolder</code> creates it with the name </br> "exampleFolder"</td></tr>
</tbody></table>
</div>
<h4 id="file-related-commands"><a class="header" href="#file-related-commands">File related commands</a></h4>
<ul>
<li>The command rm stands for "Remove", and removes the specified file or folder.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                 </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>rm fileName</code></td><td style="text-align: left"><code>Removing Files</code>: Removes the file specified in it.</td></tr>
<tr><td style="text-align: left"><code>rm -r folderName</code></td><td style="text-align: left"><code>Removing Folders</code>: Removes a folder in the same way </br> as  mkdir creates it, you need to specify which </br> folder you want to remove.</td></tr>
</tbody></table>
</div>
<ul>
<li>
<ul>
<li><em>This command is <strong>VERY DANGEROUS!</strong> If possible, <strong>DO NOT USE IT</strong>, there are a lot of memes on the internet from people using rm to delete important folders. Avoid everything that has the rm command on internet, otherwise, use it by your own discretion and responsibility!</em></li>
</ul>
</li>
<li>
<p>The command <code>mv</code>stands for "Move", and has two functionalities, to move and rename files or folders.</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>mv fileName /folderName</code></td><td style="text-align: left"><code>Moving things</code>: Using command moves the fileName </br> file to the folderName folder. In order for this command</br> to work, it is needed to write the file name </br> followed by the name of the directory that you want to</br> send the file to. For example: </br><code>mv bendFile.bend /newDirectory</code> to move a file to a </br>  folder inside the current folder.</br><code>mv bendFile.bend ../folderName</code>  to take a file to a </br> folder in a previous folder by using "../" before the name </br>of the folder.</td></tr>
<tr><td style="text-align: left"><code>mv oldFileName newFileName</code></td><td style="text-align: left"><code>Renaming things</code>: The command changes the name of a </br> file or folder to the name specified in the second </br> parameter. For example:</br><code>mv oldName.bend newName.bend</code> to rename a file from </br> "oldName.bend" to "newName.bend".</br><code>mv oldbendFolder newbendFolder</code> to rename a folder </br> from "oldbendFolder" to "newbendFolder".</td></tr>
</tbody></table>
</div>
<ul>
<li>The command touch can do a couple of complicated things, such as update file access and it's modification time. But, right now we are only gonna use it to create new files.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                 </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>touch</code></td><td style="text-align: left"><code>Creating Flies</code>: The command creates (if this file do </br> not exists yet) a new file. For example:</br> <code>touch newfile.bend</code> will create a .bend file with the </br> specified  name.</td></tr>
</tbody></table>
</div>
<h4 id="output-related-command"><a class="header" href="#output-related-command">Output related command</a></h4>
<ul>
<li>The command clear will clear your command line.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                 </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>clear</code></td><td style="text-align: left"><code>Cleaning up the mess</code>: The command will clear the </br>command line window. Use it when your terminal is </br>just a giant text wall and you will have a fresh new </br>terminal. It's very refreshing,</br> trust me!.</td></tr>
</tbody></table>
</div>
<p>The command will clear the command line window. Use it when your terminal is just a giant text wall and you will have a fresh new terminal. It's very refreshing, trust me!</p>
<p>With this basic commands, proceed to the <a href="Guide/./Installation.html">Bend Installation</a>, as we are using the terminal to do so. If you already have bend installed in your computer, proceed to the section <a href="Guide/./IDE.html">Text Editors</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install"><a class="header" href="#install">Install</a></h1>
<p>This guide teaches how to download and install <code>Bend</code> through <code>Rust</code>, using <code>Cargo</code>, a tool used for managing packages. It may be necessary to have an internet connection to proceed with this guide.</p>
<h2 id="install-depedencies"><a class="header" href="#install-depedencies">Install depedencies</a></h2>
<h3 id="on-windows"><a class="header" href="#on-windows">On Windows</a></h3>
<ol>
<li>
<p>Install Windows Subsystem for Linux (WSL2) by following the <a href="https://docs.microsoft.com/en-us/windows/wsl/install">official guide</a>.</p>
</li>
<li>
<p>After installing WSL2, open your WSL2 terminal and follow the Linux installation instructions below.</p>
</li>
</ol>
<h3 id="on-linux"><a class="header" href="#on-linux">On Linux</a></h3>
<pre><code class="language-py"># Install Rust if you haven't it already.
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# For the C version of Bend, use GCC. We recommend a version up to 12.x.
sudo apt install gcc
</code></pre>
<p>For the CUDA runtime <a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux">install the CUDA toolkit for Linux</a> version 12.x.</p>
<h3 id="on-mac"><a class="header" href="#on-mac">On Mac</a></h3>
<pre><code class="language-py"># Install Rust if you haven't it already.
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# For the C version of Bend, use GCC. We recommend a version up to 12.x.
brew install gcc
</code></pre>
<h3 id="install-bend"><a class="header" href="#install-bend">Install Bend</a></h3>
<ol>
<li>Install HVM2 by running:</li>
</ol>
<pre><code class="language-sh"># HVM2 is HOC's massively parallel Interaction Combinator evaluator.
cargo install hvm

# This ensures HVM is correctly installed and accessible.
hvm --version
</code></pre>
<ol start="2">
<li>Install Bend by running:</li>
</ol>
<pre><code class="language-sh"># This command will install Bend
cargo install bend-lang

# This ensures Bend is correctly installed and accessible.
bend --version
</code></pre>
<p>By following the above steps, we can start using Bend.</p>
<p>Now, let's proceed to <a href="Guide/./IDE.html">Text Editors</a> and finish preparing our setup for exploration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-editors"><a class="header" href="#text-editors">Text Editors</a></h1>
<p>For the VVim!</p>
<ul>
<li><em>If you already know what a Text Editor is, and already has your own favorite, proceed to the <a href="Guide/./Hello.html">Hello word!</a> section. Otherwise, this page will be very helpful.</em></li>
</ul>
<h2 id="what-is-a-text-editor"><a class="header" href="#what-is-a-text-editor">What is a Text Editor?</a></h2>
<p>It is basically a type of computer software that edits pain text.</p>
<p>When having the first contact with codes and program skills, skimming through different types of programming languages on the internet is very easy. But something may be missing there, so you start to ask yourself things like "How am i going to code?" and "Where am I going to write those codes?". And it probably is not clear yet. So this guide will try to help you in each and every step of this journey. Coding is meant to be fun, seriously!</p>
<p>First things first, before thinking about which programming language you want to learn (Probably, since you are here, that language is <code>Bend</code>) let's think about which Text Editor to use.</p>
<p>There are actually a lot of them, each one has it's own pros and cons, and probably the best way to choose is by testing them. In <a href="https://kinsta.com/blog/best-text-editors/">This blog</a>, there are 13 different types of Text Editors to look.</p>
<p>But, if you don't want to spend too much time searching an "ideal Text Editor", it is strongly recommend you to start with <a href="https://code.visualstudio.com/">Visual Studio Code</a>.
"VS Code" is the most popular text editor with the most integrations and syntax highlighting extensions that you can find out there. It's fairly simple to use, and there's a lot of tutorials on "how to use it better" on the internet.</p>
<p>Even so, this is just a recommendation, fell free to choose and use anyone of them.</p>
<p>Now that we have picked our text editor, let's start coding. And as usual, start by doing a <a href="Guide/./Hello.html">Hello word!</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>At this point, <code>bend</code> should already be installed on your machine. If not, please go back to the installation and follow the instructions.</p>
<p>In this guide, we will be using command lines and text editors, so make sure your terminal is open to proceed with the steps.</p>
<h2 id="creating-the-files"><a class="header" href="#creating-the-files">Creating the Files</a></h2>
<p>First of all, create a directory to store the bend files. It is recommended to use a dedicated directory to keep all exercises and examples, but feel free to do as you please. The three commands below will create a directory named 'bendExamples' and a file named 'hello_world.bend' inside the project directory. Use them in order:</p>
<pre><code class="language-diff">// Linux, Mac or WSL
mkdir bendExamples
cd    bendExamples
touch hello_world.bend
</code></pre>
<p>The <code>.bend</code> extension is what makes it a bend file. For example, a file that ends with <code>.exe</code> is an executable; <code>.js</code> is a JavaScript file; <code>.rs</code> is a Rust file, etc.</p>
<p>If the commands were used correctly, the hello_world.bend file should be inside the bendExamples folder. So let's have some fun, CODING!</p>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello World</a></h2>
<p>Open the <code>hello_world.bend</code> file in your text editor, it will be empty, but don't worry. From now on, there will be some advanced concepts. Everything will make sense in the future, and pertinent concepts will be explained in due time. It is recommended that you manually type the codes, instead of copying and pasting them into your file.</p>
<p>Let's write your first code in the hello_world.bend file:</p>
<pre><code class="language-py">def main():
  return "Hello, World!"
</code></pre>
<h2 id="code-check"><a class="header" href="#code-check">Code Check</a></h2>
<p>With the code ready, you should use code checking to verify that everything is in order. The code checker is still unknown in this guide, but will be explained in more detail later. For now, understand it as a checker that verifies that the file is correctly written and defined.</p>
<p>To check the code of a Bend file, simply use the <code>bend check fileName.bend</code> command. For the hello_world.bend file, it would be:</p>
<pre><code class="language-sh">bend check hello_world.bend
</code></pre>
<p>If there is no return after executing the command, it means your file is ready!</p>
<p>If the code check is  correct? So let's run the code.</p>
<h3 id="running-the-code"><a class="header" href="#running-the-code">Running the code</a></h3>
<p>To run a file in bend, use the command <code>bend run fileName.bend</code>. It should look like this:</p>
<pre><code class="language-sh">bend run hello_world.bend
</code></pre>
<p>And there you go! Your terminal should print "Hello, World!" back to you.</p>
<h3 id="remember-to-do-all-the-steps-above-check-the-type-and-then-run"><a class="header" href="#remember-to-do-all-the-steps-above-check-the-type-and-then-run">Remember to do all the steps above, check the type, and then run</a></h3>
<p>Great, now that you have your first bend program running, you can start exploring more about the language and its features. Congratulations on your progress!</p>
<p>If you have any questions or need help, don't hesitate to ask. We are always available to help!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learn-bend"><a class="header" href="#learn-bend">Learn Bend</a></h1>
<p>Bend is a high-level, massively parallel programming language. That means it feels like Python, but scales like CUDA. It runs on CPUs and GPUs, and you don't have to do anything to make it parallel: as long as your code isn't "helplessly sequential", it will use 1000's of threads!</p>
<pre><code class="language-py"># Single line comments start with a number symbol.

# There's no multi-line comment,
# but you can stack multiple comments.
</code></pre>
<h2 id="basic-types"><a class="header" href="#basic-types">Basic types</a></h2>
<p>There are numbers, all are 24 bits:</p>
<pre><code class="language-py">420  # unsigned integers
+69  # uigned integers
1.4  # floating point
</code></pre>
<!--
There are also binary and hexadecimal literals:

```py
0b1001_1011  # binary
0x1234_abcd  # hexadecimal
-0xbeef      # hexadecimal signed
```
-->
<p>There are character literals:</p>
<pre><code class="language-py">'x'
</code></pre>
<ul>
<li>A Character is surrounded with <code>'</code>.
<ul>
<li>Accepts unicode characters like <code>'β'</code> and Unicode escapes in the form <code>'\u{hex value}'</code>.</li>
<li>The value is desugared to a 24-bit unsigned integer (<code>u24</code>).</li>
<li>Support Unicode codepoints up to <code>0xFFFFFF</code>.</li>
</ul>
</li>
</ul>
<p>There are string literals:</p>
<pre><code class="language-py">"Hello, World!"
</code></pre>
<ul>
<li>A String literal is surrounded with <code>"</code>.
<ul>
<li>Accepts the same as character literals.</li>
</ul>
</li>
</ul>
<p>Tuples can contain 2 or more elements. they are separated by <code>,</code>.</p>
<pre><code class="language-py">(1, 2)  # tuple

# pattern match
(x1, x2, ..., xn) = ("Hi", 2, ..., 'N')
# x1 = "Hi"
# x2 = 2
# ...
# xn = 'N'

(fst, snd) = (1, "Hello", ..., 'N')
# fst = 1
# snd = ("Hello", ..., 'N')
</code></pre>
<p>Lists that are implemented as linked lists.</p>
<pre><code class="language-py">[1,2,3] # list

# list comprehensions
[x + 1 for x in [1,2,3]]  # Result: [2, 3, 4]

# with a conditional
[x * 2 for x in [1,2,3] if x &gt; 2]  # Result: [6, 8]
</code></pre>
<p>Map is an efficient binary tree with <code>u24</code> keys. It offers O(log n) read and write operations.</p>
<pre><code class="language-py">{ 0: 4, 'c': 2 + 3 , ... } # Map

# updating values using keys
map = { 0: "zero", 1: "one", 2: "two", 3: "three" }
map[0] = "not zero"      # update the value at key 0
map[1] = 2               # update the value at key 1
map[2] = 3               # update the value at key 2

# Using keys in operations
map[3] = map[1] + map[map[1]]  # Use the value at key 1 and the value at key map[1]
</code></pre>
<ul>
<li>Keys must values that can be cast to a <code>u24</code> number.
<ul>
<li>The values can be of any type, but mixing types can make reasoning about the map harder.</li>
</ul>
</li>
</ul>
<p>Map is an efficient binary tree with <code>u24</code> keys. It offers O(log n) read and write operations.</p>
<pre><code class="language-py">{ 0: 4, 'c': 2 + 3 , ... } # Map

# pattern match
map = { 0: "zero", 1: "one", 2: "two", 3: "three" }

# Updating values using keys
map[0] = "not zero"      # Update the value at key 0
map[1] = 2               # Update the value at key 1
map[2] = 3               # Update the value at key 2

# Using keys in operations
map[3] = map[1] + map[map[1]]  # Use the value at key 1 and the value at key map[1]
</code></pre>
<ul>
<li>keys can be literals or expressions that evaluate to <code>u24</code>.
<ul>
<li>The values can be of any type, but mixing types can make reasoning about the map harder.</li>
</ul>
</li>
</ul>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>Some math</p>
<ul>
<li>Bend supports operations only between identical types of numbers.</li>
</ul>
<pre><code class="language-py">10 + 10 =&gt; 20   # ADD
10 -  5 =&gt; 5    # SUB
5  *  2 =&gt; 10   # MUL
10 /  2 =&gt; 5    # DIV
10 %  3 =&gt; 1    # REM
10 &gt;&gt; 1 =&gt; 5    # SHR
10 &lt;&lt; 1 =&gt; 20   # SHL
10.0 ** 2.0 =&gt; 100.0  # POW
</code></pre>
<ul>
<li>In Bend the operator <code>**</code> is exclusive to the<code>f24</code> type.</li>
</ul>
<p>Booleans are represented with <code>u24</code>/<code>i24</code> integers <code>0</code> and <code>1</code>.</p>
<p>There are the boolean operators: <code>&amp;</code>, <code>|</code> and <code>^</code>.</p>
<pre><code class="language-py">1 &amp; 1 =&gt; 1  # AND
1 | 0 =&gt; 1  # OR
1 ^ 1 =&gt; 0  # XOR
</code></pre>
<ul>
<li>In Bend the boolean operators are exclusive to <code>u24</code> and <code>i24</code>.</li>
</ul>
<p>For comparisons we have: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code> and <code>&lt;=</code>, which return <code>u24</code>.</p>
<pre><code class="language-py">1.0 == 1.0 =&gt; 1  # EQ
1   !=  1  =&gt; 0  # NEQ
-1  &lt;  +2  =&gt; 1  # LT
1   &gt;   2  =&gt; 0  # GT
2   &lt;=  2  =&gt; 1  # LTE
1.0 &gt;= 2.0 =&gt; 0  # GTE
</code></pre>
<!-- `False`, `Nil`, `None` and `Empty` values will evaluate to `0`. All others evalauate to `1`. -->
<h2 id="basic-functions"><a class="header" href="#basic-functions">Basic Functions</a></h2>
<p>Defines a top level function.
use <code>def</code> to define your functions.</p>
<pre><code class="language-py">def add(x, y):
  result = x + y
  return result

def main:
  return add(40, 2)
</code></pre>
<ul>
<li>A function definition is composed by a name, a sequence of parameters and a body.
<ul>
<li>A top-level name can be anything matching the regex <code>[A-Za-z0-9_.-/]+</code>, except it can't have <code>__</code> (used for generated names) or start with <code>//</code>.</li>
<li>The last statement of each function must either be a return or a selection statement (<code>if</code>, <code>switch</code>, <code>match</code>, <code>fold</code>) where all branches <code>return</code>.</li>
</ul>
</li>
</ul>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<pre><code class="language-py">if condition:
  return "condition is true"
else:
  return "condition is false"
</code></pre>
<ul>
<li>A branching statement where <code>else</code> is mandatory.
<ul>
<li>The condition must return a <code>u24</code>, where 0 is false.</li>
</ul>
</li>
</ul>
<p>It is possible to make if-chains using <code>elif</code>:</p>
<pre><code class="language-py">if condition1:
  return 0
elif condition2:
  return 1
elif condition3:
  return 2
else:
  return 3
</code></pre>
<p>Switches may only be used with native numbers values. It lets us check for many cases at the same time.</p>
<ul>
<li>Beginning with 0 and incrementing by 1. The last case must be <code>_</code>, like a <code>default</code> case.</li>
</ul>
<pre><code class="language-py">switch number:
  case 0:
    return 6
  case 1:
    return 7
  case _: # default
    return number - 2
</code></pre>
<p>Use <code>switch</code> instead of nesting many <code>if</code> expressions.</p>
<pre><code class="language-py">switch condition:
  case 0:
    # else branch
    return 1
  case _: # default
    # then branch
    return 0
</code></pre>
<p>Remember pattern matching? Many control-flow structures in Bend rely on it.</p>
<p><code>match</code> allows us to compare a value against many patterns.
the cases must be the constructor names of the matching value.</p>
<pre><code class="language-py">match variable:
  case type/constructor1:
    # This will match and bind `type/constructor1`
    return variable.field1
  case type/constructor2:
    # This will match and bind `type/constructor2`
    return variable.value2
  ...
</code></pre>
<p>A <code>fold</code> statement. Reduces the given value with the given match cases.</p>
<pre><code class="language-py">fold variable:
  case type/constructor1:
    return variable.value1 + variable.field1 - variable.field2 ...
  case type/constructor2:
    return variable.value2 ...
  ...
</code></pre>
<ul>
<li>You can use fold to reduce a <code>type</code>
<ul>
<li>For fields notated with <code>~</code> in the type definition, the fold function is called implicitly.</li>
</ul>
</li>
</ul>
<p>It is equivalent to the inline recursive function:</p>
<pre><code class="language-py">def fold(x)
  match x:
    case type/constructor1:
      return x.value1 + fold(x.field1) - fold(x.field2) ...
    case type/constructor2:
      return x.value2 ...
    ...
</code></pre>
<p>Bend doesn't have loops; it uses recursion instead.</p>
<p><code>bend</code> is naturally suited for handling recursive data structures. Unlike traditional loops, <code>bend</code> uses recursive calls to repeat operations.</p>
<pre><code class="language-py">bend initialization: # init branch
  when condition:    # when branch
    # code block to be executed
    fork(increment) # optional
  else:              # end branch
    # block of code to be executed a final bend
</code></pre>
<ul>
<li>In <code>bend</code>, state variables are passed explicitly.
<ul>
<li>It is possible to pass multiple state variables, which can be initialized.</li>
<li>When calling <code>fork</code>, the function must receive the same number of arguments as those passed during initialization.</li>
</ul>
</li>
</ul>
<p>It is equivalent to this inline recursive function:</p>
<pre><code class="language-py">def bend(x, y, ...):
  if condition(x, y, ...):
    ...
    return ... bend(x, y, ...) ...
  else:
    return ...
</code></pre>
<p>Open</p>
<pre><code class="language-py">open object: variable
...
return object { field1: variable.field1, field2: ... }
</code></pre>
<ul>
<li>Brings the inner fields of an <code>object</code> into scope.
<ul>
<li>The original variable can still be accessed, but doing so will cause any used fields to be duplicated.</li>
</ul>
</li>
</ul>
<p>It's equivalent to pattern matching on the <code>object</code>, with the restriction that its type must have only one constructor.</p>
<pre><code class="language-py">match variable:
  case object:
    ...
</code></pre>
<h3 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h3>
<p>Algebraic data type</p>
<ul>
<li>Type names must be unique, and should have at least one constructor.
<ul>
<li>Each constructor is defined by a name followed by its fields.</li>
</ul>
</li>
</ul>
<pre><code class="language-py">type Option:
  Some { value }
  None

type Map:
  Node { value, ~left, ~right }
  Leaf
</code></pre>
<ul>
<li>The <code>~</code> notation indicates a recursive field.
<ul>
<li>The constructor names inherit the name of their types and become functions <code>Map/Node</code> and <code>Map/Leaf</code>.</li>
<li>The exact function they become depends on the encoding.</li>
</ul>
</li>
</ul>
<p>Defines a type with a single constructor (like a struct, a record or a class).</p>
<pre><code class="language-py">object Pair { fst, snd }

object Function { name, args, body }

object Vec { len, data }
</code></pre>
<p>The constructor created from this definition has the same name as the type.</p>
<h2 id="more-functions"><a class="header" href="#more-functions">More Functions</a></h2>
<p>todo</p>
<p>Bind also provides many built-in functions</p>
<p>todo</p>
<h2 id="io"><a class="header" href="#io">IO</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-in-bend"><a class="header" href="#comments-in-bend">Comments in Bend</a></h1>
<p>In Bend, comments are used to add explanations or notes to the code, which are ignored by the compiler. Comments are useful for documenting the code and making it more readable for other developers (or for yourself in the future).</p>
<h2 id="single-line-comments"><a class="header" href="#single-line-comments">Single-Line Comments</a></h2>
<p>Single-line comments start with the hash symbol (<code>#</code>). All text after the hash symbol on the same line is considered a comment and is ignored by the compiler.</p>
<p>Example: Single-Line Comments
Here is an example of using single-line comments in Bend:</p>
<pre><code class="language-py">def example():
  # This is a single-line comment
  x = 10  # This comment explains the variable x
  return x
</code></pre>
<h2 id="multi-line-comments"><a class="header" href="#multi-line-comments">Multi-Line Comments</a></h2>
<p>Bend does not have a native mechanism for multi-line comments, like comment blocks found in other languages. However, you can stack multiple single-line comments to create a multi-line comment.</p>
<p>Example: Multi-Line Comments
Here is an example of using multi-line comments in Bend:</p>
<pre><code class="language-py">def example_multiline():
  # This is a multi-line comment
  # that explains the code below in detail.
  # Each line starts with the hash symbol.
  y = 20
  return y
</code></pre>
<h2 id="improving-readability-with-comments"><a class="header" href="#improving-readability-with-comments">Improving Readability with Comments</a></h2>
<p>Comments should be used to clarify the purpose of the code, explain complex logic, and provide additional context. Avoid unnecessary or obvious comments that do not add value to understanding the code.</p>
<p>Example: Clear and Useful Comments
Here is an example of how to use comments clearly and usefully:</p>
<pre><code class="language-py">def fib(n):
  # Function to calculate the nth Fibonacci number
  switch n:
    case 0:
      return 0  # Returns 0 if n is 0
    case 1:
      return 1  # Returns 1 if n is 1
    case _:
      # Recursively calculates Fibonacci for n-1 and n-2
      return fib(n - 1) + fib(n - 2)
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Single-line comments: Start with <code>#</code>.</li>
<li>Multi-line comments: Stack multiple single-line comments.</li>
</ul>
<p>Comments are a powerful tool for improving code readability and maintenance.
Use them wisely to document your code in Bend.</p>
<pre><code class="language-py">def main():
  example = example() # Should return 10
  example_multiline = example_multiline() # Should return 20
  fib = fib(5) # Should return 5
  return fib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers-in-bend"><a class="header" href="#numbers-in-bend">Numbers in Bend</a></h1>
<p>In Bend, you can work with various types of numbers, including unsigned integers, signed integers, and floating-point numbers, all 24 bits wide. Additionally, you can use binary and hexadecimal literals, as well as character literals that can be converted to <code>u24</code>.</p>
<h2 id="number-types"><a class="header" href="#number-types">Number Types</a></h2>
<h3 id="unsigned-integers"><a class="header" href="#unsigned-integers">Unsigned Integers</a></h3>
<p>24-bit unsigned integers can be used to represent positive integer values.
unsigned_number = 420  Unsigned integer (24 bits)</p>
<h3 id="signed-integers"><a class="header" href="#signed-integers">Signed Integers</a></h3>
<p>24-bit signed integers can be used to represent positive and negative integer values.
signed_number = +69  Signed integer (24 bits)</p>
<h3 id="floating-point-numbers"><a class="header" href="#floating-point-numbers">Floating-Point Numbers</a></h3>
<p>24-bit floating-point numbers can be used to represent numeric values with a fractional part.
floating_number = 1.4  Floating point (24 bits)</p>
<h2 id="binary-and-hexadecimal-literals"><a class="header" href="#binary-and-hexadecimal-literals">Binary and Hexadecimal Literals</a></h2>
<h3 id="binary"><a class="header" href="#binary">Binary</a></h3>
<p>You can use binary literals to represent numbers in base 2.
binary_number = 0b100_100  Binary</p>
<h3 id="hexadecimal"><a class="header" href="#hexadecimal">Hexadecimal</a></h3>
<p>You can use hexadecimal literals to represent numbers in base 16.
hexadecimal_number = 0x123_abc  Hexadecimal
signed_hexadecimal_number = -0xbeef  Signed hexadecimal</p>
<h3 id="character-literals"><a class="header" href="#character-literals">Character Literals</a></h3>
<p>Character literals are represented by a single character enclosed in single quotes.
They accept Unicode characters and Unicode escapes in the form '\u{hexadecimal value}'.
character = 'x'</p>
<h3 id="conversion-of-character-literals-to-u24"><a class="header" href="#conversion-of-character-literals-to-u24">Conversion of Character Literals to <code>u24</code></a></h3>
<p>A character literal is desugared to a 24-bit unsigned integer (<code>u24</code>).
This means each character can be treated as an integer corresponding to its Unicode code point.</p>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p>There is also support for native operations. In "Imp" syntax they are infix operators and in "Fun" syntax they are written in reverse polish notation (like you'd call a normal function). Each operation takes two arguments and returns a new number.</p>
<h3 id="in-fun-syntax"><a class="header" href="#in-fun-syntax">In Fun syntax</a></h3>
<p>some_val = (+ (+ 7 4) (* 2 3))</p>
<p>These are the currently available operations:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Description</th><th>Accepted types</th><th>Return type</th></tr></thead><tbody>
<tr><td>+</td><td>Addition</td><td>U24, I24, F24</td><td>Same as arguments</td></tr>
<tr><td>-</td><td>Subtraction</td><td>U24, I24, F24</td><td>Same as arguments</td></tr>
<tr><td>*</td><td>Multiplication</td><td>U24, I24, F24</td><td>Same as arguments</td></tr>
<tr><td>/</td><td>Division</td><td>U24, I24, F24</td><td>Same as arguments</td></tr>
<tr><td>%</td><td>Modulo</td><td>U24, I24, F24</td><td>Same as arguments</td></tr>
<tr><td>==</td><td>Equality</td><td>U24, I24, F24</td><td>U24</td></tr>
<tr><td>!=</td><td>Inequality</td><td>U24, I24, F24</td><td>U24</td></tr>
<tr><td>&lt;</td><td>Less than</td><td>U24, I24, F24</td><td>U24</td></tr>
<tr><td>&lt;=</td><td>Less than or equal to</td><td>U24, I24, F24</td><td>U24</td></tr>
<tr><td>&gt;</td><td>Greater than</td><td>U24, I24, F24</td><td>U24</td></tr>
<tr><td>&gt;=</td><td>Greater than or equal to</td><td>U24, I24, F24</td><td>U24</td></tr>
<tr><td>&amp;</td><td>Bitwise and</td><td>U24, I24</td><td>Same as arguments</td></tr>
<tr><td>|</td><td>Bitwise or</td><td>U24, I24</td><td>Same as arguments</td></tr>
<tr><td>^</td><td>Bitwise xor</td><td>U24, I24</td><td>Same as arguments</td></tr>
<tr><td>**</td><td>Exponentiation</td><td>F24</td><td>F24</td></tr>
</tbody></table>
</div>
<p>Functions</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>Accepted types</th><th>Return type</th></tr></thead><tbody>
<tr><td>log(x, base)</td><td>Logarithm</td><td>F24</td><td>F24</td></tr>
<tr><td>atan2(x, y)</td><td>2 arguments arctangent (atan2f)</td><td>F24</td><td>F24</td></tr>
</tbody></table>
</div>
<p>Testing the conversion function</p>
<pre><code class="language-py">def main():
  ex01 = 'A'        # Should return 65 (Unicode value of 'A')
  ex02 = '\u{123}'  # Should return 291 (Unicode value of '\u{123}')
  return ex02
</code></pre>
<p>Unicode Code Point Support
Bend supports Unicode code points up to 0xFFFFFF, allowing the representation of a wide range of international characters.</p>
<p>Summary:</p>
<ul>
<li>Unsigned integers: <code>420</code></li>
<li>Signed integers: <code>+69</code></li>
<li>Floating-point numbers: <code>1.4</code></li>
<li>Binary: <code>0b100_100</code></li>
<li>Hexadecimal: <code>0x123_abc</code>, <code>-0xbeef</code></li>
<li>Character literals: <code>'x'</code>, <code>'\u{123}'</code></li>
<li>Conversion of characters to <code>u24</code>: Each character is treated as a <code>u24</code> integer
corresponding to its Unicode code point.</li>
</ul>
<p>Bend offers a range of numeric types and support for character literals, making it easy to work with numeric and text data efficiently and intuitively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-in-bend"><a class="header" href="#variables-in-bend">Variables in Bend</a></h1>
<p>Bend allows the use of variables to store values. Variables are declared with an equals sign and can be used anywhere a literal value would be used.</p>
<h2 id="dynamic-typing"><a class="header" href="#dynamic-typing">Dynamic Typing</a></h2>
<p>Variables in Bend are dynamically typed, which means that the type of a variable is determined by the value it holds. Variables can hold any type of value, including integers, floats, strings, lists, tuples, maps, and functions.</p>
<h2 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case Sensitivity</a></h2>
<p>Variables in Bend are case-sensitive, which means that variables with different names are considered distinct even if only the capitalization is different. For example, <code>variable</code> and <code>Variable</code> are different variables.</p>
<h2 id="variable-reassignment"><a class="header" href="#variable-reassignment">Variable Reassignment</a></h2>
<p>Variables can be reassigned at any time. This allows a variable to change the value it stores during the execution of the program.</p>
<ul>
<li>Use in Mathematical Expressions</li>
<li>Variables can store values and perform calculations.</li>
<li>They can also hold the return values from functions.</li>
</ul>
<h2 id="example-of-variables-in-bend"><a class="header" href="#example-of-variables-in-bend">Example of Variables in Bend</a></h2>
<p>Below is an example that demonstrates the declaration and use of variables in Bend:</p>
<pre><code class="language-py">def main():
  # Declaring variables of different types
  string = "Hello, World!"              # String
  integer = 42                          # Integer
  floating_point = 3.14                 # Float
  list = [1, 2, 3, 4, 5]                # List
  tuple = (1, 2, 3, 4, 5)               # Tuple
  map = {'k': "value", 'j': "value2"}   # Map

  # Declaring a lambda function and storing it in a variable
  function = lambda x: x + 1

  # Using the function variable to calculate the return value
  result = function(integer)

  return result
</code></pre>
<h2 id="in-the-example-above"><a class="header" href="#in-the-example-above">In the example above</a></h2>
<ul>
<li><code>string</code> stores a string "Hello, World!".</li>
<li><code>integer</code> stores an integer 42.</li>
<li><code>floating_point</code> stores a float number 3.14.</li>
<li><code>list</code> stores a list of integers [1, 2, 3, 4, 5].</li>
<li><code>tuple</code> stores a tuple of integers (1, 2, 3, 4, 5).</li>
<li><code>map</code> stores a map with keys 'k' and 'j', and values "value" and "value2".</li>
<li><code>function</code> stores a lambda function that adds 1 to its argument.</li>
<li><code>result</code> stores the value returned by the <code>function</code> when applied to <code>integer</code>.</li>
</ul>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<ul>
<li>are declared using the <code>=</code> (equals) sign;</li>
<li>dynamically typed;</li>
<li>case-sensitive.</li>
<li>can be reassigned;</li>
<li>store values and perform calculations;</li>
<li>hold return values from functions.</li>
</ul>
<p>With these features, variables in Bend provide a flexible and powerful way to manage data and logic in your programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tail-recursion-in-bend"><a class="header" href="#tail-recursion-in-bend">Tail Recursion in Bend</a></h1>
<p>Tail recursion is a special form of recursion where the recursive call is the last operation to be executed before the function returns a value. This allows the programming language to optimize execution by reusing the same stack frame for recursive calls, instead of creating new ones. This optimization is known as tail call optimization.</p>
<p>Bend, based on the HVM (High Order Virtual Machine), is a language that supports tail call optimization. This results in more efficient use of memory and better performance for recursive functions that follow this pattern. In fact, all recursion in Bend is optimized as tail recursion due to the characteristics of the HVM.</p>
<h2 id="characteristics-of-tail-recursion"><a class="header" href="#characteristics-of-tail-recursion">Characteristics of Tail Recursion</a></h2>
<ul>
<li>Final Recursive Call: The recursive call is the last thing that happens
in the function.</li>
<li>No Pending Operations: There are no additional operations after the recursive
call. Any calculation or operation must be completed before the recursive
call.</li>
</ul>
<h3 id="example-of-traditional-recursion-vs-tail-recursion"><a class="header" href="#example-of-traditional-recursion-vs-tail-recursion">Example of Traditional Recursion vs. Tail Recursion</a></h3>
<h4 id="traditional-recursion"><a class="header" href="#traditional-recursion">Traditional Recursion</a></h4>
<p>Here is an example of a traditional recursive function that calculates the factorial
of a number:</p>
<pre><code class="language-py">def factorial(n):
  switch n:
    case 0:
      return 1
    case _:
      return n * factorial(n - 1)
</code></pre>
<p>In this version, the multiplication <code>n * factorial(n - 1)</code> occurs after the recursive call, which means the operation is not tail recursion.</p>
<h4 id="tail-recursion"><a class="header" href="#tail-recursion">Tail Recursion</a></h4>
<p>Here is the same function rewritten to use tail recursion:</p>
<pre><code class="language-py">def factorial_tail(n):
  return factorial_tail_aux(n, 1)

def factorial_tail_aux(n, acc):
  switch n:
    case 0:
      return acc
    case _:
      return factorial_tail_aux(n - 1, n * acc)
</code></pre>
<p>In this version, the recursive call <code>factorial_tail_aux(n - 1, n * acc)</code> is the last operation of the function, allowing Bend to optimize the recursion.</p>
<h3 id="practical-example-in-bend"><a class="header" href="#practical-example-in-bend">Practical Example in Bend</a></h3>
<p>Let's create a tail recursive function to calculate the Fibonacci sequence in Bend:</p>
<pre><code class="language-py">def fib_tail(n):
  return fib_tail_aux(n, 0, 1)

def fib_tail_aux(n, a, b):
  switch n:
    case 0:
      return a
    case 1:
      return b
    case _:
      return fib_tail_aux(n - 1, b, a + b)
</code></pre>
<p>In this function, <code>fib_tail_aux(n - 1, b, a + b)</code> is the last operation, ensuring the function is tail recursive.</p>
<h4 id="benefits-of-tail-recursion"><a class="header" href="#benefits-of-tail-recursion">Benefits of Tail Recursion</a></h4>
<ul>
<li>Memory Efficiency: Tail call optimization allows the same stack frame to be reused, preventing excessive stack growth and saving memory.</li>
<li>Improved Performance: By avoiding the creation of new stack frames for each recursive call, performance can be significantly improved.</li>
<li>Prevents Stack Overflow: In languages that do not support tail call optimization, deep recursion can lead to stack overflow. With tail call optimization, this is mitigated.</li>
</ul>
<h3 id="implementation-in-the-hvm"><a class="header" href="#implementation-in-the-hvm">Implementation in the HVM</a></h3>
<p>The HVM, which is the basis of Bend, allows efficient execution of recursion due to its lazy evaluation mechanism and the use of "REF nodes" to expand on demand. This means that memory is used consistently even in deep recursions.</p>
<h4 id="example-of-implementation-in-the-hvm"><a class="header" href="#example-of-implementation-in-the-hvm">Example of implementation in the HVM</a></h4>
<pre><code class="language-hs">(IsNat Z)     = True
(IsNat (S p)) = (IsNat p)
</code></pre>
<p>This does not "grow forever" because, in the case <code>(IsNat Z)</code>, it reduces directly to <code>True</code>, using a constant amount of memory.</p>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>Tail recursion is a powerful technique that can lead to more efficient and better-performing programs, especially in languages that support its optimization, such as Bend. By ensuring that the recursive call is the last operation in a function, you allow the compiler or interpreter to optimize execution, saving memory and preventing stack overflow.</p>
<pre><code class="language-py">def main():
  tail_factorial = factorial_tail(5)
  factorial = factorial(5)
  fib = fib_tail(10)
  return fib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-in-bend"><a class="header" href="#types-in-bend">Types in Bend</a></h1>
<p>In Bend, types are fundamental for defining the structure and nature of the data that a program can manipulate. They allow the creation of complex data structures and help ensure data integrity and consistency throughout the program's execution.</p>
<h2 id="defining-types"><a class="header" href="#defining-types">Defining Types</a></h2>
<p>To define a type in Bend, we use the <code>type</code> keyword. A type can have multiple constructors, each with its own fields. Here is the basic syntax for defining a type:</p>
<pre><code class="language-rs">type TypeName:
  Constructor1 {value, field1, field2, ...}
  Constructor2 {field1, field2, ...}
  ...
</code></pre>
<p>Example: Defining a Vector Type</p>
<p>Let's create a <code>Vector</code> type that represents a list of elements. Each element is a pair of an integer and an associated value. Here is the definition of the <code>Vector</code> type:</p>
<pre><code class="language-rs">type Vector:
  Nil
  Cons {n, head, ~tail}
</code></pre>
<p>In this example, the <code>Vector</code> type has two constructors:</p>
<ul>
<li><code>Nil</code>, which represents an empty list;</li>
<li><code>Cons</code>, which represents an element of the list.</li>
</ul>
<p>The <code>Cons</code> constructor has three fields:</p>
<ul>
<li><code>n</code>, which is an integer;</li>
<li><code>head</code>, which is the associated value; and</li>
<li><code>tail</code>, which is the rest of the list.</li>
</ul>
<p>Additional Example: Days of the Week</p>
<p>Here is an example of defining a type to represent the days of the week and a function that determines the next weekday:</p>
<p>Defining the <code>Day</code> Type</p>
<pre><code class="language-rs">type Day:
  monday
  tuesday
  wednesday
  thursday
  friday
  saturday
  sunday
</code></pre>
<p>Here we define the <code>Day</code> type with seven constructors, one for each day of the week.</p>
<p><code>NextWeekday</code> Function</p>
<p>The <code>NextWeekday</code> function takes a value of type <code>Day</code> and returns the next weekday. We use pattern matching to define the behavior of the function for each day of the week.</p>
<pre><code class="language-py">def NextWeekday(day):
  match day:
    case Day/monday:
      return Day/tuesday
    case Day/tuesday:
      return Day/wednesday
    case Day/wednesday:
      return Day/thursday
    case Day/thursday:
      return Day/friday
    case _:
      return Day/monday
</code></pre>
<p>In this example, we define the <code>NextWeekday</code> function that maps each day of the week to the next weekday. Note that Friday, Saturday, and Sunday should return Monday, as we only consider weekdays, hence the <code>_</code> pattern at the end.</p>
<h2 id="creating-instances-of-types"><a class="header" href="#creating-instances-of-types">Creating Instances of Types</a></h2>
<p>To create an instance of a defined type, we use its constructors. Here is an example of how to create a vector with three elements:</p>
<pre><code class="language-py">def ex1():
  # Create a vector with three elements: (2, "a"), (1, "b"), and (0, "c")
  my_vector = Vector/Cons(2, "a", Vector/Cons(1, "b", Vector/Cons(0, "c", Vector/Nil)))
  return my_vector
</code></pre>
<p>In this example, we create a vector with three elements: (2, "a"), (1, "b"), and (0, "c"). The vector is built from the end, starting with the last element and adding the previous elements. The result is a linked list of elements, where each element points to the next. Creating types in Bend is a powerful way to structure and manipulate complex data.</p>
<h2 id="testing-the-function"><a class="header" href="#testing-the-function">Testing the Function</a></h2>
<p>To verify the functionality of the <code>NextWeekday</code> function, we create a <code>main</code> function that
tests the function with some examples:</p>
<pre><code class="language-py">def main():
  my_vector = ex1()
  # Two weekdays after Saturday
  nextWeekday = NextWeekday(NextWeekday(Day/saturday))
  return nextWeekday
</code></pre>
<p>When running the code above, the expected result is <code>Day/tuesday</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects-in-bend"><a class="header" href="#objects-in-bend">Objects in Bend</a></h1>
<p>In Bend, an object defines a type with a single constructor, similar to a structure (struct), a record, or a class. Objects allow the creation of complex data types with multiple fields.</p>
<h2 id="defining-objects"><a class="header" href="#defining-objects">Defining Objects</a></h2>
<p>To define an object in Bend, we use the <code>object</code> keyword. The definition of an object specifies the fields it has.</p>
<h2 id="example-defining-simple-objects"><a class="header" href="#example-defining-simple-objects">Example: Defining Simple Objects</a></h2>
<p>Here are some examples of object definitions:</p>
<pre><code class="language-py">object Pair { fst, snd }

object Function { name, args, body }

object Vec { len, data }
</code></pre>
<p>In these examples, we define three objects: Pair, Function, and Vec, each with their respective fields.
The constructor created from this definition has the same name as the type.</p>
<p>Example: Defining an Account Object</p>
<p>Let's define an Account object with two fields: number and balance.</p>
<pre><code class="language-py">object Account {
  number,
  balance
}
</code></pre>
<p>In this example, we define an Account object with two fields: number and balance.
The Account constructor has two parameters: number and balance.</p>
<h2 id="creating-and-manipulating-objects"><a class="header" href="#creating-and-manipulating-objects">Creating and Manipulating Objects</a></h2>
<p>To create an instance of an object, we use its constructor. We can access and manipulate the fields of an object using the <code>open</code> keyword.</p>
<p>Example: Creating an Instance of Account
Below is an example of <code>createAccount1</code> and <code>createAccount2</code> functions that create instances of the Account object:</p>
<pre><code class="language-py">def createAccount1():
  return Account { number: "1234-56", balance: 10000.00 }

def createAccount2():
  return Account { number: "1234-57", balance: 20000.00 }
</code></pre>
<h2 id="function-to-withdraw-an-amount-from-an-account"><a class="header" href="#function-to-withdraw-an-amount-from-an-account">Function to withdraw an amount from an account</a></h2>
<p>This function uses the <code>balance</code> field of the <code>Account</code> object to calculate the balance after withdrawal.</p>
<pre><code class="language-py">def withdraw(amount, account):
  open Account: account
  return ("Actual balance", (account.balance - amount))

Main function demonstrating the usage of the above functions
def main():
  account1 = createAccount1()
  account2 = createAccount2()
  return withdraw(6000.00, account1)
</code></pre>
<p>In this example:</p>
<ul>
<li>We use <code>open</code> to access the number and balance fields of the Account object.</li>
<li>We use <code>return</code> to return an instance of the Account object with the
fields number and balance filled with the provided values.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples-in-bend"><a class="header" href="#tuples-in-bend">Tuples in Bend</a></h1>
<p>In Bend, a tuple can contain two or more elements. The elements are separated by commas.</p>
<h2 id="defining-tuples"><a class="header" href="#defining-tuples">Defining Tuples</a></h2>
<p>To define a tuple, we use parentheses and separate the elements with commas.</p>
<p>Example: Defining Simple Tuples
Here are some examples of tuple definitions:</p>
<p>(1, 2) tuple with two elements</p>
<p>We can do pattern matching on tuples:
(fst, snd, ..., lst) = ("Hi", 2, ..., lst)
fst = "Hi"
snd = 2
... = ...
lst = lst</p>
<p>(fst, snd) = (1, "Hello", ..., lst)
fst = 1
snd = ("Hello", ..., lst)</p>
<h2 id="creating-and-manipulating-tuples"><a class="header" href="#creating-and-manipulating-tuples">Creating and Manipulating Tuples</a></h2>
<p>To create and manipulate tuples, we use the syntax of parentheses and commas.
Below is an example of functions that return the first, second, and third elements of a tuple:</p>
<pre><code class="language-py">def return_fst(t):
  (fst, snd) = t
  return fst

def return_snd(t):
  (fst, snd) = t
  return snd

def return_trd(t):
  (fst, snd, trd) = t
  return trd

# Main function demonstrating the usage of the above functions
def main():
  tupl = (1, 2, 3, 4)
  fst = return_fst(tupl) # 1
  snd = return_snd(tupl) # (2, (3, 4))
  trd = return_trd(tupl) # (3, 4)
  return trd # (3, 4)
</code></pre>
<h2 id="in-this-example"><a class="header" href="#in-this-example">In this example</a></h2>
<ul>
<li>We create a tuple <code>tupl</code> with four elements: (1, 2, 3, 4).</li>
<li>We use the function <code>return_fst</code> to return the first element of the tuple, which is 1.</li>
<li>We use the function <code>return_snd</code> to return the second element of the tuple, which is (2, (3, 4)).</li>
<li>We use the function <code>return_trd</code> to return the third element of the tuple, which is (3, 4).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">List</a></h1>
<pre><code class="language-rs"> type List:
   Cons {head, ~tail}
   Nil
</code></pre>
<p>The List type is a native type in Bend, used to represent ordered sequences of elements.
It is defined by two main constructors: Cons and Nil.</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<ul>
<li>Cons: This constructor is used to create a list with an element and a tail. It takes two arguments:
<ul>
<li>head: The value of the first element of the list.</li>
<li>tail: The tail of the list, which is another List object.</li>
</ul>
</li>
<li>Nil: This constructor represents an empty list. It takes no arguments and is used to indicate the end of the list.</li>
</ul>
<h2 id="visual-representation"><a class="header" href="#visual-representation">Visual Representation</a></h2>
<p>A list can be visualized as a chain of nodes, where each node contains a value and a reference to the next node. The last node, which does not point to any other node, is represented by Nil.</p>
<p>Example:
Cons(1, Cons(2, Cons(3, Nil))) -&gt; 1 -&gt; 2 -&gt; 3 -&gt; Nil</p>
<p>In this example, we have a list containing the values 1, 2, and 3, ending with Nil.</p>
<h2 id="alternative-notation"><a class="header" href="#alternative-notation">Alternative Notation</a></h2>
<p>To simplify the reading and writing of lists, we can use a more familiar notation, where elements are listed between square brackets and separated by commas.</p>
<p>Examples:</p>
<ul>
<li>[1, 2, 3] is equivalent to Cons(1, Cons(2, Cons(3, Nil))).</li>
<li>[] is equivalent to Nil, representing an empty list.</li>
<li>[1] is equivalent to Cons(1, Nil), representing a list with a single element.</li>
</ul>
<p>Example of Usage in Code:
Below is an example of a main function that returns the list ["Hello", "world!"]:</p>
<pre><code class="language-py">def main():
  return List/Cons("Hello", List/Cons("world!", List/Nil))
</code></pre>
<p>In this example, the main function constructs a list with two elements, "Hello" and "world!", using the Cons and Nil constructors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maps-in-bend"><a class="header" href="#maps-in-bend">Maps in Bend</a></h1>
<p>In Bend, a Map represents a tree with values stored in the branches. It is intended to be used as an efficient map data structure with integer keys and O(log n) read and write operations.</p>
<h2 id="defining-maps"><a class="header" href="#defining-maps">Defining Maps</a></h2>
<p>To define a Map in Bend, we use the type keyword. A Map can have two constructors: Node and Leaf.</p>
<p>Example: Defining a Map</p>
<pre><code class="language-rs">type Map:
  Node { value, ~left, ~right }
  Leaf
</code></pre>
<ul>
<li>Node { value, ~left, ~right }:
<ul>
<li>Represents a map node with a value and left and right subtrees.</li>
<li>Empty nodes have * stored in the value field.</li>
</ul>
</li>
<li>Leaf:
<ul>
<li>Represents an unwritten and empty portion of the map.</li>
</ul>
</li>
</ul>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>Here is how you create a new Map with some initial values:</p>
<p>{ 0: 4, <code>hi</code>: "bye", 'c': 2 + 3 }</p>
<p>Keys must be U24 numbers and can be given as literals or any other expression that evaluates to a U24.</p>
<p>Values can be anything, but storing data of different types in a Map will make it harder to understand.</p>
<p>You can read and write a value from a map with the [] operator:</p>
<p>map = { 0: "zero", 1: "one", 2: "two", 3: "three" }
map[0] = "not zero"
map[1] = 2
map[2] = 3
map[3] = map[1] + map[map[1]]</p>
<p>Here, map should be the name of the Map variable, and the keys inside [] can be any expression that evaluates to a U24.</p>
<p>Map is an efficient binary tree with U24 keys. It offers O(log n) read and write operations.</p>
<p>{ 0: 4, 'c': 2 + 3 , ... } # Map</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>We can do pattern matching with Maps:</p>
<p>map = { 0: "zero", 1: "one", 2: "two", 3: "three" }</p>
<h2 id="updating-values-using-keys"><a class="header" href="#updating-values-using-keys">Updating Values Using Keys</a></h2>
<p>We can update values using keys:</p>
<p>map[0] = "not zero"      # Updates the value at key 0
map[1] = 2               # Updates the value at key 1
map[2] = 3               # Updates the value at key 2</p>
<h2 id="using-keys-in-operations"><a class="header" href="#using-keys-in-operations">Using Keys in Operations</a></h2>
<p>We can use keys in operations:</p>
<p>map[3] = map[1] + map[map[1]]  # Uses the value at key 1 and the value at key map[1]</p>
<p>Keys can be literals or expressions that evaluate to u24. Values can be of any type, but mixing types can make reasoning about the map more difficult.</p>
<pre><code class="language-py">def main():
  map = { 0: "zero", 1: "one", 2: "two", 3: "three" }
  return map[2] # should return "two"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trees-in-bend"><a class="header" href="#trees-in-bend">Trees in Bend</a></h1>
<p>Bend has native support for trees, a hierarchical data structure with nodes connected by edges.</p>
<h2 id="tree-definition"><a class="header" href="#tree-definition">Tree Definition</a></h2>
<p>In Bend, a tree (<code>Tree</code>) is defined with two constructors:</p>
<ul>
<li><code>Node { ~left, ~right }</code>: Represents a tree node with left and right subtrees.</li>
<li><code>Leaf { value }</code>: Represents a tree leaf that stores a value.</li>
</ul>
<p>Trees are ideal for algorithms that benefit from parallel recursion, as they allow large problems to be divided into smaller subproblems.</p>
<h2 id="tree-syntax"><a class="header" href="#tree-syntax">Tree Syntax</a></h2>
<p>Bend provides the <code>![]</code> operator to create tree branches and the <code>!</code> operator to create a tree leaf.</p>
<ul>
<li><code>![a, b]</code> is equivalent to <code>Tree/Node { left: a, right: b }</code></li>
<li><code>!x</code> is equivalent to <code>Tree/Leaf { value: x }</code></li>
</ul>
<p>Example: Building a Tree in Bend</p>
<pre><code class="language-py">def main():
  tree = ![![!1, !2], ![!3, !4]]
  return tree
</code></pre>
<p>In this example, we create a binary tree with leaves containing the values 1, 2, 3, and 4,
representing the following tree:</p>
<pre><code class="language-md">     node
   /     \
  node    node
 /   \   /   \
1     2 3     4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrices-in-bend"><a class="header" href="#matrices-in-bend">Matrices in Bend</a></h1>
<p>In Bend, matrices are not a native type. Therefore, a common way to construct matrices is by using lists of lists, as it is not a native type. Each inner list represents a row of the matrix.</p>
<p>Example: Building a Matrix in Bend
Here is an example of how we can build a matrix in Bend using lists of lists:</p>
<pre><code class="language-py">matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
</code></pre>
<p>In this example, we have a 3x3 matrix with values from 1 to 9 organized into three rows and three columns. We can access the elements of the matrix using double indices. For example, <code>matrix[0][0]</code> gives us the element in the first row and first column, which is 1.</p>
<p>This is a flexible and convenient way to represent matrices in Bend, allowing easy access to elements and manipulation of data structures.</p>
<pre><code class="language-py">def main():
  return matrix
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs-in-bend"><a class="header" href="#graphs-in-bend">Graphs in Bend</a></h1>
<p>In Bend, graphs are not a native type. Therefore, an efficient way to create a graph is by using a map of lists of pairs. Each key in the map represents a node, and the list of pairs associated with that key represents the edges connecting that node to other nodes, along with the associated distances.</p>
<p>Example: Building a Graph in Bend
Here is an example of how we can build a graph in Bend using a map of lists of pairs:</p>
<pre><code class="language-py">def main():
  graph = {
    'a': [(4, 'b'), (1, 'c')],
    'b': [(4, 'a'), (13, 'c'), (2, 'd')],
    'c': [(1, 'a'), (13, 'b'), (5, 'd')],
    'd': [(2, 'b'), (5, 'c')]
  }
  return graph
</code></pre>
<p>In this example, we have a graph with four nodes ("a", "b", "c", "d") and several edges with associated distances.</p>
<ul>
<li>Node 'a' is at a distance of 4 from node 'b' and at a distance of 1 from node 'c'.</li>
<li>Node 'b' is at a distance of 4 from node 'a', 13 from node 'c', and at a distance of 2 from node 'd'.</li>
<li>Node 'c' is at a distance of 1 from node 'a', 13 from node 'b', and at a distance of 5 from node 'd'.</li>
<li>Node 'd' is at a distance of 2 from node 'b' and at a distance of 5 from node 'c'.</li>
</ul>
<p>Visually, the graph can be represented as follows:</p>
<pre><code class="language-md"> a - 4 - b
 |     / |
 1   13  2
 | /     |
 c - 5 - d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-in-bend"><a class="header" href="#functions-in-bend">Functions in Bend</a></h1>
<p>Bend is a language that supports defining functions in a concise and expressive manner. Functions are reusable blocks of code that perform specific operations and return values.</p>
<h2 id="function-definition"><a class="header" href="#function-definition">Function Definition</a></h2>
<p>Functions are defined using the <code>def</code> keyword followed by the function name, parameters in parentheses, and a body.</p>
<pre><code class="language-py">def sum(a, b):
  result = a + b
  return result
</code></pre>
<p>The <code>sum</code> function takes two parameters <code>a</code> and <code>b</code>, and returns their sum.</p>
<h2 id="anonymous-functions-lambdas"><a class="header" href="#anonymous-functions-lambdas">Anonymous Functions (Lambdas)</a></h2>
<p>Bend supports anonymous functions, also known as lambdas, which are defined using the <code>lambda x: expression</code> syntax.</p>
<p>Example of an anonymous function that increments a number:</p>
<pre><code class="language-py">def lambda_inc:
  inc = lambda x: x + 1
  return inc
</code></pre>
<p>This function can be called in the same way as a named function:
result = lambda_inc(5)  # result is 6</p>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h2>
<p>Higher-order functions are those that accept other functions as parameters or return functions.</p>
<p>Example of a function that accepts another function as a parameter:</p>
<pre><code class="language-py">def apply_two_times(f, x):
  return f(f(x))
</code></pre>
<p>Using the <code>apply_two_times</code> function with an anonymous function:
result = apply_two_times(lambda x: x + 1, 5)  # result is 7</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>Bend supports recursion, allowing a function to call itself.</p>
<p>Example of a recursive function to calculate the factorial of a number:</p>
<pre><code class="language-py">def factorial(n):
  if n == 0:
    return 1
  else:
    return n * factorial(n - 1)
</code></pre>
<p>Recursive functions in Bend are optimized for tail recursion, resulting in better performance and efficient memory usage.</p>
<h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h2>
<p>Functions can use pattern matching to decompose values and make decisions based on those values.</p>
<p>Example of a function that uses pattern matching to calculate the factorial:</p>
<pre><code class="language-py">def factorial_match(n):
  switch n:
    case 0:
      return 1
    case _:
      return n * factorial_match(n - 1)
</code></pre>
<h2 id="currying"><a class="header" href="#currying">Currying</a></h2>
<p>In Bend, functions can be partially applied through currying, allowing a function with multiple parameters to be transformed into a chain of functions that each take a single parameter.</p>
<p>Example of a curried function:</p>
<pre><code class="language-py">def curried_sum(a):
  return lambda b: a + b
</code></pre>
<p>Using the curried function:</p>
<pre><code class="language-py">sum5    = curried_sum(5)
sum5_3  = sum5(3)  # result is 8
</code></pre>
<p>Conclusion</p>
<p>Functions in Bend are powerful and flexible, allowing for the creation of modular and reusable code. With support for anonymous functions, recursion, currying, and pattern matching, Bend facilitates writing concise and expressive functions.</p>
<pre><code class="language-py">def main():
  sum_result = sum(2, 3)
  lambda_inc_result = lambda_inc(5)
  higher_order_result = apply_two_times(lambda_inc, 5)
  recursive_result = factorial(5)
  factorial_match_result = factorial_match(5)
  sum5 = curried_sum(5)
  sum5_3_result = sum5(3)
  return sum5_3_result
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-statements"><a class="header" href="#if-statements"><code>IF</code> Statements</a></h1>
<p>Making Decisions Based on Conditions in Bend a common way to implement this is by using conditional statements, such as if and else.</p>
<h2 id="the-basic-structure-of-if-else"><a class="header" href="#the-basic-structure-of-if-else">The Basic Structure of if-else</a></h2>
<p>The if-else structure allows our program to execute different blocks of code depending
on whether a condition is true or false.</p>
<pre><code class="language-py">def if_else(cond): 
  if cond:
    return "condition is true"
  else:
    return "condition is false"
</code></pre>
<p>Here, cond is the condition we are evaluating. If cond is true, the function returns
"condition is true". Otherwise, it returns "condition is false".</p>
<h3 id="importance-of-else"><a class="header" href="#importance-of-else">Importance of else</a></h3>
<p>Unlike some languages where else may be optional, in Bend else is mandatory. This
ensures that there is always an execution path, even if the initial condition is not
met.</p>
<h3 id="the-condition"><a class="header" href="#the-condition">The Condition</a></h3>
<p>In the above structure, cond should return a u24 (a 24-bit integer), where 0 represents false and any other value represents true.</p>
<pre><code class="language-py">def if_else_u24(cond):
  if cond != 0:
    return "condition is true"
  else:
    return "condition is false"
</code></pre>
<h4 id="chaining-conditions-with-elif"><a class="header" href="#chaining-conditions-with-elif">Chaining Conditions with elif</a></h4>
<p>For situations where we need to evaluate multiple conditions, we use elif. This allows
us to create chains of conditions where several conditions are tested in sequence
until one of them is true.</p>
<pre><code class="language-py">def else_if(cond):
  if cond == 1:
    return 0
  elif cond &gt; 1:
    return 1
  elif cond &lt; 1:
    return 2
  else:
    return 3
</code></pre>
<p>Here, we have a function that returns different values depending on the value of cond:</p>
<ul>
<li>If cond is true, it returns 0.</li>
<li>If cond is greater than 1, it returns 1.</li>
<li>If cond is less than 1, it returns 2.</li>
<li>If none of the above conditions are true, it returns 3.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="switch-statements"><a class="header" href="#switch-statements"><code>Switch</code> Statements</a></h1>
<p><code>Switch</code> statements offer a structured and efficient way to select among multiple conditions based on a specific value. In some programming languages, using <code>switch</code> statements can simplify the control flow logic compared to multiple <code>if-else</code> statements.</p>
<h2 id="basic-structure-of-switch"><a class="header" href="#basic-structure-of-switch">Basic Structure of <code>Switch</code></a></h2>
<p>The <code>switch</code> construct is used to associate a variable name with the result of a given condition and branch to the case that matches its value.</p>
<h3 id="ordering-of-cases"><a class="header" href="#ordering-of-cases">Ordering of Cases</a></h3>
<p>The cases must be listed from smallest to largest, starting at <code>0</code> and incrementing by <code>1</code>.</p>
<h3 id="default-case-_"><a class="header" href="#default-case-_">Default Case (<code>_</code>)</a></h3>
<p>The last case must be <code>_</code>, which catches all values not explicitly enumerated.</p>
<h3 id="native-values"><a class="header" href="#native-values">Native Values</a></h3>
<p><code>Switch</code> statements can only be used with native numeric values.</p>
<p>Let's examine a basic example:</p>
<pre><code class="language-python">def switch_example(x):
  switch x:
    case 0:
      return 6
    case 1:
      return 7
    case _:
      return x - 2
</code></pre>
<p>In this example, the <code>switch</code> checks the value of <code>x</code> and returns a result based on the corresponding case:</p>
<ul>
<li>If <code>x</code> is <code>0</code>, it returns <code>6</code>.</li>
<li>If <code>x</code> is <code>1</code>, it returns <code>7</code>.</li>
<li>For all other values (<code>_</code>), it returns <code>x - 2</code>.</li>
</ul>
<p>In the last case, the value of the predecessor is available with the name <code>bound_var-next_num</code>, where <code>bound_var</code> is the variable defined by the condition and <code>next_num</code> is the expected value of the next case. Let's detail this with a more specific example.</p>
<h2 id="implementing-switch-using-if-else"><a class="header" href="#implementing-switch-using-if-else">Implementing <code>Switch</code> Using <code>If-Else</code></a></h2>
<p>We can see that the <code>switch</code> structure can be converted to a series of <code>if-else</code> statements:</p>
<pre><code class="language-python">def switch_case(x):
  if x == 0:
    return 6
  elif x == 1:
    return 7
  else:
    return x - 2
</code></pre>
<h3 id="comparative-example"><a class="header" href="#comparative-example">Comparative Example</a></h3>
<p>Let's see how a <code>switch</code> can be equivalent to an <code>if-else</code> from the previous section:</p>
<pre><code class="language-python">def if_else_equiv(condition):
  if condition == 0:
    # then branch
    return 1
  else:
    # else branch
    return 0
</code></pre>
<h3 id="equivalent-to-switch"><a class="header" href="#equivalent-to-switch">Equivalent to <code>Switch</code></a></h3>
<pre><code class="language-python">def switch_equiv_expl(condition):
  switch condition == 0: # explicit
    case 0:
      # else branch
      return 0
    case _:
      # then branch
      return 1
</code></pre>
<pre><code class="language-python">def switch_equiv_impl(condition):
  switch condition: # implicit
    case 0:
      return 1
    case _:
      return 0
</code></pre>
<p>Both functions above implement the same logic but using different control structures.</p>
<h3 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h3>
<p>Using <code>switch</code> can make your code clearer and more readable when dealing with many conditions and is more efficient than multiple <code>if-else</code> statements. It is a powerful control flow tool that complements traditional <code>if-else</code> structures.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-statements"><a class="header" href="#match-statements"><code>Match</code> Statements</a></h1>
<p>Bend offers a powerful pattern matching system through the <code>match</code> construct. It allowsfor clear and safe control flow, enabling clear and concise deconstruction of values, with the ability to bind variables to fields of the constructors. With <code>match</code>, you can write expressive and robust code to handle different types of data efficiently</p>
<h2 id="basic-structure-of-match"><a class="header" href="#basic-structure-of-match">Basic Structure of <code>match</code></a></h2>
<p>The <code>match</code> structure examines a value and allows executing different code blocks based on the corresponding value's constructor. Here's a basic example:</p>
<h3 id="pattern-matching-2"><a class="header" href="#pattern-matching-2">Pattern Matching</a></h3>
<p>Patterns in <code>match</code> must cover the possible variants of the type being matched.</p>
<h3 id="variable-binding"><a class="header" href="#variable-binding">Variable Binding</a></h3>
<p>It is possible to bind a variable name to the corresponding value. The fields of the associated constructor are bound to <code>matched_var.field_name</code>.</p>
<h3 id="assignment"><a class="header" href="#assignment">Assignment</a></h3>
<p>For fields within the constructor, you can use variables specified in the case body.</p>
<h3 id="default-case-_-1"><a class="header" href="#default-case-_-1">Default Case (<code>_</code>)</a></h3>
<p>The default case must be <code>_</code>, which catches all values not explicitly enumerated.</p>
<p>Consider the definition of a type <code>Option</code>:</p>
<pre><code class="language-python">type Option:
  None
  Some {value}
</code></pre>
<pre><code class="language-python">def match_example(x):
  match x:
    case Option/None:
      return 0
    case Option/Some:
      return x.value
</code></pre>
<p>In this example, the variable <code>x</code> can be an instance of <code>Option/Some</code> or <code>Option/None</code>. The matching logic determines the value based on the constructor of <code>x</code>.</p>
<ul>
<li>If <code>x</code> is an instance of <code>Option/None</code>, <code>0</code> is returned.</li>
<li>If <code>x</code> is an instance of <code>Option/Some</code>, the field <code>value</code> is returned.</li>
</ul>
<h3 id="detailed-example"><a class="header" href="#detailed-example">Detailed Example</a></h3>
<p>Consider a type <code>Direction</code>:</p>
<pre><code class="language-python">type Direction:
  Up
  Down
  Left
  Right
</code></pre>
<pre><code class="language-python">def direction_to_string(direction):
  match direction:
    case Direction/Up:
      return "Up"
    case Direction/Down:
      return "Down"
    case Direction/Left:
      return "Left"
    case Direction/Right:
      return "Right"
</code></pre>
<p>In this example, <code>direction_to_string</code> converts a <code>Direction</code> value to a corresponding string.</p>
<h3 id="nested-structures"><a class="header" href="#nested-structures">Nested Structures</a></h3>
<p>Consider a binary tree:</p>
<pre><code class="language-python">type BTree:
  Leaf
  Node {value, left, right}
</code></pre>
<pre><code class="language-python">def sum_tree(btree):
  match btree:
    case BTree/Leaf:
      return 0
    case BTree/Node:
      return btree.value + sum_tree(btree.left) + sum_tree(btree.right)
</code></pre>
<p>Here, <code>sum_tree</code> calculates the sum of all values in a binary tree:</p>
<ul>
<li>If <code>tree</code> is <code>BTree/Leaf</code>, it returns <code>0</code>.</li>
<li>If <code>tree</code> is <code>BTree/Node</code>, it sums the current node's value with the sums of the left and right subtrees.</li>
</ul>
<h3 id="now-lets-apply-the-match_example-function-and-test-it"><a class="header" href="#now-lets-apply-the-match_example-function-and-test-it">Now let's apply the <code>match_example</code> function and test it</a></h3>
<pre><code class="language-python">def main():
  some_value = Option/Some(42)
  none_value = Option/None
  return (match_example(none_value),  # Output: 0
          match_example(some_value))  # Output: 42
</code></pre>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p><code>Match</code> statements provide a clear and powerful way to deconstruct values based on their constructors. They allow binding variables to the fields of corresponding constructors, making it easier to work with algebraic data types and resulting in more readable and organized code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fold-statements"><a class="header" href="#fold-statements"><code>Fold</code> Statements</a></h1>
<p><code>Fold</code> statements provide a powerful way to reduce a data structure by recursively applying a function and combining the results. Another language that has <code>fold</code> is Haskell, where it is a fundamental technique for operating on data structures like lists and trees. The <code>fold</code> in Bend is equivalent to <code>foldl</code> in Haskell.</p>
<h2 id="basic-structure-of-fold"><a class="header" href="#basic-structure-of-fold">Basic Structure of <code>Fold</code></a></h2>
<p>The <code>fold</code> structure reduces the given value based on the provided matching cases.</p>
<h3 id="bound-fields"><a class="header" href="#bound-fields">Bound Fields</a></h3>
<p>Just like in <code>match</code>, we can bind variable names to the corresponding values.</p>
<h3 id="implicit-fold-calls"><a class="header" href="#implicit-fold-calls">Implicit <code>fold</code> Calls</a></h3>
<p>For fields annotated with <code>~</code> in the type definition, the <code>fold</code> function is implicitly called.</p>
<p>Suppose a tree definition where the subtree fields are annotated with <code>~</code>:</p>
<pre><code class="language-python">type BTree:
  Leaf
  Node {value, ~left, ~right}
</code></pre>
<p>Here, <code>Node</code> represents an internal tree node with a value and left and right subtrees, while <code>Leaf</code> represents a tree leaf.</p>
<h3 id="fold-example"><a class="header" href="#fold-example"><code>Fold</code> Example</a></h3>
<p>With this definition, we can use the <code>fold</code> function implicitly. Let's create a <code>fold</code> that sums all the node values in the tree:</p>
<pre><code class="language-python">def sum_btree(btree):
  fold btree:
    case BTree/Leaf:
      return 0
    case BTree/Node:
      return btree.value + btree.left + btree.right
</code></pre>
<p>In this example:</p>
<ul>
<li>If the <code>tree</code> matches <code>Leaf</code>, we return <code>0</code>.</li>
<li>If the <code>tree</code> matches <code>Node</code>, we sum the node's value with the results of the recursive <code>fold</code> calls on the <code>left</code> and <code>right</code> subtrees.</li>
</ul>
<h3 id="equivalence-with-recursive-function"><a class="header" href="#equivalence-with-recursive-function">Equivalence with Recursive Function</a></h3>
<p>A <code>fold</code> statement is equivalent to an inline recursive function. The above example can be rewritten equivalently using an explicit recursive function:</p>
<pre><code class="language-python">def fold(tree):
  match tree:
    case BTree/Leaf:
      return 0
    case BTree/Node:
      return tree.value + fold(tree.left) + fold(tree.right)
</code></pre>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p><code>Fold</code> statements provide an elegant way to reduce complex data structures like trees by recursively applying a function. By allowing field binding and implicit <code>fold</code> calls, this structure facilitates clear and efficient manipulation and aggregation of data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-bend-construction-in-bend"><a class="header" href="#the-bend-construction-in-bend">The <code>bend</code> Construction in Bend</a></h1>
<p>The <code>bend</code> construction in Bend is a powerful and versatile tool used to create recursive data structures and emulate iterative processes in a declarative and functional manner. It allows you to define a recursive process that builds a complex structure step-by-step until a specific condition is met.</p>
<h2 id="basic-structure"><a class="header" href="#basic-structure">Basic Structure</a></h2>
<p>The <code>bend</code> construction initializes a recursive process with an initial state and iterates until a specified condition is met. It is similar to an embedded recursive function.</p>
<pre><code class="language-python">bend &lt;state_variables&gt;:
  when &lt;condition&gt;:
    &lt;recursive_operations&gt;
  else:
    &lt;termination_operations&gt;
</code></pre>
<h3 id="initialization-of-state-variables"><a class="header" href="#initialization-of-state-variables">Initialization of State Variables</a></h3>
<p>The state variables are initialized in the header of the <code>bend</code>. There can be multiple state variables, each with an initial value.</p>
<h3 id="immutable-state"><a class="header" href="#immutable-state">Immutable State</a></h3>
<p>The state variables are treated immutably, ensuring that each recursive step has a consistent and predictable state.</p>
<h3 id="structured-recursion"><a class="header" href="#structured-recursion">Structured Recursion</a></h3>
<p>The <code>bend</code> starts a recursive construction, initializing a state and executing a block of code until a stopping condition is met.</p>
<h3 id="controlled-recursion"><a class="header" href="#controlled-recursion">Controlled Recursion</a></h3>
<p>The <code>bend</code> construction offers explicit control over recursion, allowing you to clearly define when the recursion should continue and when it should stop.</p>
<h3 id="continuation-condition"><a class="header" href="#continuation-condition">Continuation Condition</a></h3>
<p>The <code>when</code> clause defines the condition under which the recursion continues. If the condition is true, the recursive operations are executed. If the condition is false, the termination operations are executed.</p>
<h3 id="recursive-operations"><a class="header" href="#recursive-operations">Recursive Operations</a></h3>
<p>Within the <code>when</code> clause, the <code>fork</code> function is used to call the <code>bend</code> recursively with new values for the state variables. The number of arguments passed to <code>fork</code> must match the number of state variables.</p>
<h3 id="termination-operations"><a class="header" href="#termination-operations">Termination Operations</a></h3>
<p>When the condition is no longer true, the termination operations are executed in the <code>else</code> clause. This clause defines the final behavior and values returned by the <code>bend</code> construction.</p>
<h3 id="incremental-construction"><a class="header" href="#incremental-construction">Incremental Construction</a></h3>
<p>It allows building recursive data structures by adding layers or branches at each recursive call.</p>
<h3 id="flexibility"><a class="header" href="#flexibility">Flexibility</a></h3>
<p>The ability to manipulate multiple state variables and construct different types of data structures makes the <code>bend</code> a flexible and powerful tool for various applications.</p>
<h3 id="versatility"><a class="header" href="#versatility">Versatility</a></h3>
<p>Besides creating recursive data structures, the <code>bend</code> can be used to simulate iterative processes.</p>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="example-1-creating-a-binary-tree"><a class="header" href="#example-1-creating-a-binary-tree">Example 1: Creating a Binary Tree</a></h3>
<pre><code class="language-python">def create_tree():
  bend x = 0:
    when x &lt; 3:
      left = fork(x + 1)
      right = fork(x + 1)
      tree = ![left, right]
    else:
      tree = !x
  return tree
</code></pre>
<p>This code creates a binary tree:</p>
<ul>
<li>Initializes <code>x = 0</code>.</li>
<li>Continues recursion while <code>x &lt; 3</code>.</li>
<li>Within the <code>when</code> clause, <code>fork(x + 1)</code> recursively calls the <code>bend</code> with an incremented value of <code>x</code>.</li>
<li>Creates tree nodes with <code>![left, right]</code>.</li>
<li>Ends recursion with <code>!x</code> when <code>x &gt;= 3</code>.</li>
</ul>
<h3 id="example-2-sum-calculation-with-emulated-loop"><a class="header" href="#example-2-sum-calculation-with-emulated-loop">Example 2: Sum Calculation with Emulated Loop</a></h3>
<p>The <code>bend</code> is general enough to emulate a loop by recursively iterating over a state until a termination condition is met. For example, this Python program:</p>
<pre><code class="language-python">sum = 0
idx = 0
while idx &lt; 10:
  sum = idx + sum
  idx = idx + 1
</code></pre>
<p>can be rewritten using <code>bend</code>:</p>
<pre><code class="language-python">def loop():
  bend idx = 0:
    when idx &lt; 10:
      sum = idx + fork(idx + 1)
    else:
      sum = 0
  return sum
</code></pre>
<p>This code emulates a loop that sums integers from <code>0</code> to <code>9</code> using recursion:</p>
<ul>
<li>Initializes <code>idx = 0</code>.</li>
<li>Continues recursion while <code>idx &lt; 10</code>.</li>
<li>Iterates over <code>idx</code>, incrementing it by <code>1</code>.</li>
<li>Computes the sum of integers from <code>0</code> to <code>9</code>, adding the current <code>idx</code> value to the sum of the next iteration.</li>
<li>Ends recursion returning <code>0</code> when <code>idx &gt;= 10</code>.</li>
</ul>
<h3 id="multiple-state-variables"><a class="header" href="#multiple-state-variables">Multiple State Variables</a></h3>
<p>The <code>bend</code> can handle multiple state variables simultaneously, enabling complex recursive processes.</p>
<pre><code class="language-python">def mult_var():
  bend x = 1, y = 2:
    when x &lt; 10 &amp; y &lt; 20:
      result = fork(x + 1, y + 2)
    else:
      result = (x, y)
  return result
</code></pre>
<p>This code creates a tuple:</p>
<ul>
<li>Initializes <code>x = 1</code> and <code>y = 2</code>.</li>
<li>Continues recursion while <code>x &lt; 10</code> and <code>y &lt; 20</code>.</li>
<li>Increments <code>x</code> and <code>y</code> differently at each recursive step.</li>
<li>Ends recursion returning the values of <code>(x, y)</code> when one of the conditions is no longer true.</li>
</ul>
<h3 id="recursive-data-structures"><a class="header" href="#recursive-data-structures">Recursive Data Structures</a></h3>
<p>The <code>bend</code> construction can be used to build complex recursive data structures, such as trees, linked lists, and graphs.</p>
<pre><code class="language-python">def repeat(target):
  bend n = 0:
    when n &lt; target:
      list = List/Cons(n, fork(n + 1))
    else:
      list = []
  return list
</code></pre>
<p>This code creates a linked list:</p>
<ul>
<li>Initializes <code>n = 0</code>.</li>
<li>Continues recursion while <code>n &lt; target</code>.</li>
<li>Creates list nodes with <code>[n, (n + 1), ..., (n &lt; target)]</code>.</li>
<li>Ends recursion with <code>[]</code> when <code>n &gt;= target</code>.</li>
</ul>
<h3 id="practical-examples-and-exercises"><a class="header" href="#practical-examples-and-exercises">Practical Examples and Exercises</a></h3>
<h4 id="example-1-factorial"><a class="header" href="#example-1-factorial">Example 1: Factorial</a></h4>
<p>Calculate the factorial of a number using <code>bend</code>.</p>
<pre><code class="language-python">def factorial(n):
  # code
  return acc
</code></pre>
<h4 id="example-2-fibonacci-sequence"><a class="header" href="#example-2-fibonacci-sequence">Example 2: Fibonacci Sequence</a></h4>
<p>Generate the Fibonacci sequence up to the 10th term.</p>
<pre><code class="language-python">def fibonacci(n):
  # code
  return 
</code></pre>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>The <code>bend</code> construction in Bend is a powerful and flexible tool for defining recursive processes, generating complex data structures, state manipulation, and emulating iterative behaviors in a clear and expressive manner. It combines elements of functional programming and recursive data manipulation to build complex structures incrementally and expressively. Understanding its rules and behavior is essential to utilize the full potential of this construction and apply these concepts to real-world programming problems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-statements-em-bend"><a class="header" href="#open-statements-em-bend">Open Statements em Bend</a></h1>
<h2 id="introdução"><a class="header" href="#introdução">Introdução</a></h2>
<p>Os <code>open statements</code> em Bend são uma construção sintática que permite trazer os campos internos de um objeto para o escopo local. Isso facilita o acesso e a manipulação desses campos, tornando o código mais limpo e legível, especialmente quando se trabalha com objetos complexos.</p>
<h2 id="conceito-e-funcionamento"><a class="header" href="#conceito-e-funcionamento">Conceito e Funcionamento</a></h2>
<h3 id="sintaxe-básica"><a class="header" href="#sintaxe-básica">Sintaxe Básica</a></h3>
<pre><code class="language-bend">open TypeName: objectVariable
</code></pre>
<h3 id="comportamento"><a class="header" href="#comportamento">Comportamento</a></h3>
<ol>
<li>Traz os campos do objeto para o escopo local.</li>
<li>Permite acesso direto aos campos sem referenciar o objeto.</li>
<li>O objeto original ainda pode ser acessado.</li>
<li>Os campos usados são efetivamente duplicados no escopo local.</li>
</ol>
<h2 id="comparação-com-outras-linguagens"><a class="header" href="#comparação-com-outras-linguagens">Comparação com Outras Linguagens</a></h2>
<h3 id="desestruturação-em-javascript"><a class="header" href="#desestruturação-em-javascript">Desestruturação em JavaScript</a></h3>
<pre><code class="language-javascript">const point = { x: 1, y: 2 };
const { x, y } = point;
</code></pre>
<h3 id="pattern-matching-em-rust"><a class="header" href="#pattern-matching-em-rust">Pattern Matching em Rust</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point { x: f64, y: f64 }
let point = Point { x: 1.0, y: 2.0 };
let Point { x, y } = point;
<span class="boring">}</span></code></pre></pre>
<h2 id="vantagens-dos-open-statements"><a class="header" href="#vantagens-dos-open-statements">Vantagens dos Open Statements</a></h2>
<ol>
<li><strong>Clareza</strong>: Reduz a verbosidade ao trabalhar com campos de objetos.</li>
<li><strong>Escopo Local</strong>: Limita o acesso aos campos apenas onde necessário.</li>
<li><strong>Flexibilidade</strong>: Permite usar tanto os campos locais quanto o objeto original.</li>
</ol>
<h2 id="aplicações-práticas"><a class="header" href="#aplicações-práticas">Aplicações Práticas</a></h2>
<h3 id="exemplo-1-cálculo-de-distância"><a class="header" href="#exemplo-1-cálculo-de-distância">Exemplo 1: Cálculo de Distância</a></h3>
<pre><code class="language-bend">object Point { x, y }

def distance(a, b):
  open Point: a
  open Point: b
  dx = b.x - a.x
  dy = b.y - a.y
  return (dx * dx + dy * dy) ** 0.5

def main():
  p1 = Point { x: 0, y: 0 }
  p2 = Point { x: 3, y: 4 }
  return distance(p1, p2)
</code></pre>
<h3 id="exemplo-2-transformação-de-objetos"><a class="header" href="#exemplo-2-transformação-de-objetos">Exemplo 2: Transformação de Objetos</a></h3>
<pre><code class="language-bend">object Rectangle { width, height }

def scale(rect, factor):
  open Rectangle: rect
  return Rectangle { 
    width: width * factor, 
    height: height * factor 
  }

def main():
  original = Rectangle { width: 10, height: 20 }
  scaled = scale(original, 1.5)
  return scaled
</code></pre>
<h2 id="considerações-avançadas"><a class="header" href="#considerações-avançadas">Considerações Avançadas</a></h2>
<h3 id="1-escopo-e-shadowing"><a class="header" href="#1-escopo-e-shadowing">1. Escopo e Shadowing</a></h3>
<p>O <code>open statement</code> pode potencialmente sombrear variáveis existentes no escopo atual. É importante estar ciente disso para evitar confusões:</p>
<pre><code class="language-bend">def example():
  x = 5
  p = Point { x: 10, y: 20 }
  open Point: p
  # Aqui, 'x' se refere ao campo de 'p', não à variável original
  return x  # Retorna 10, não 5
</code></pre>
<h3 id="2-uso-com-tipos-complexos"><a class="header" href="#2-uso-com-tipos-complexos">2. Uso com Tipos Complexos</a></h3>
<p>Para tipos mais complexos, o <code>open statement</code> pode simplificar significativamente o código:</p>
<pre><code class="language-bend">object ComplexData { 
  id, 
  metadata: { 
    created_at, 
    updated_at 
  }, 
  content 
}

def process_data(data):
  open ComplexData: data
  open metadata: metadata
  # Agora temos acesso direto a id, created_at, updated_at, e content
  ...
</code></pre>
<h3 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h3>
<p>Em termos de performance, o <code>open statement</code> é geralmente uma operação de baixo custo, pois não cria cópias profundas dos dados, apenas referências locais.</p>
<h2 id="melhores-práticas"><a class="header" href="#melhores-práticas">Melhores Práticas</a></h2>
<ol>
<li><strong>Use com Moderação</strong>: Embora conveniente, o uso excessivo de <code>open</code> pode tornar o código difícil de seguir.</li>
<li><strong>Escopos Limitados</strong>: Prefira usar <code>open</code> em escopos menores e bem definidos.</li>
<li><strong>Documentação</strong>: Quando usar <code>open</code> em funções públicas, documente claramente quais campos estão sendo expostos.</li>
<li><strong>Consistência</strong>: Mantenha um estilo consistente ao usar <code>open</code> em todo o seu código.</li>
</ol>
<h2 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h2>
<p>Os <code>open statements</code> em Bend oferecem uma maneira elegante e eficiente de trabalhar com campos de objetos. Eles melhoram a legibilidade e a manutenibilidade do código, especialmente ao lidar com estruturas de dados complexas. Ao usar essa feature com sabedoria, os desenvolvedores podem escrever código mais conciso e expressivo, mantendo a clareza e a intenção do programa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocos-with-em-bend"><a class="header" href="#blocos-with-em-bend">Blocos <code>with</code> em Bend</a></h1>
<h2 id="introdução-1"><a class="header" href="#introdução-1">Introdução</a></h2>
<p>Os blocos <code>with</code> em Bend são uma construção poderosa que permite trabalhar com computações monádicas de forma elegante e concisa. Eles são particularmente úteis para lidar com operações que podem falhar, computações assíncronas ou qualquer sequência de operações que precise manter um contexto específico.</p>
<h2 id="conceito-de-mônadas"><a class="header" href="#conceito-de-mônadas">Conceito de Mônadas</a></h2>
<p>Antes de aprofundarmos nos blocos <code>with</code>, é importante entender o conceito de mônadas:</p>
<ol>
<li>Uma mônada é uma estrutura da teoria das categorias que encapsula computações e seus efeitos.</li>
<li>Em programação funcional, mônadas são usadas para sequenciar computações e gerenciar efeitos colaterais de forma controlada.</li>
<li>Exemplos comuns de mônadas incluem <code>Maybe</code> (para valores opcionais), <code>Result</code> (para operações que podem falhar) e <code>IO</code> (para operações de entrada/saída).</li>
</ol>
<h2 id="estrutura-e-funcionamento-dos-blocos-with"><a class="header" href="#estrutura-e-funcionamento-dos-blocos-with">Estrutura e Funcionamento dos Blocos <code>with</code></a></h2>
<h3 id="sintaxe-básica-1"><a class="header" href="#sintaxe-básica-1">Sintaxe Básica</a></h3>
<pre><code class="language-bend">with MonadType:
  x &lt;- monadic_operation1()
  y &lt;- monadic_operation2(x)
  return wrap(some_function(x, y))
</code></pre>
<h3 id="componentes-chave"><a class="header" href="#componentes-chave">Componentes Chave</a></h3>
<ol>
<li><strong>Tipo Monádico</strong>: Especificado após <code>with</code> (ex: <code>Result</code>, <code>IO</code>).</li>
<li><strong>Operações Monádicas</strong>: Usam a sintaxe <code>x &lt;- operation()</code>.</li>
<li><strong>Função <code>bind</code></strong>: Deve ser definida para o tipo monádico (ex: <code>Result/bind</code>).</li>
<li><strong>Função <code>wrap</code></strong>: Usada para envolver valores no tipo monádico.</li>
</ol>
<h3 id="exemplo-detalhado-mônada-result"><a class="header" href="#exemplo-detalhado-mônada-result">Exemplo Detalhado: Mônada <code>Result</code></a></h3>
<pre><code class="language-bend">type Result a = Result/Ok(value: a) | Result/Err(error: String)

def Result/bind(res, nxt):
  match res:
    case Result/Ok:
      nxt = undefer(nxt)
      return nxt(res.value)
    case Result/Err:
      return res

def Result/wrap(x):
  return Result/Ok(x)

def safe_div(x, y):
  if y == 0:
    return Result/Err("Divisão por zero")
  else:
    return Result/Ok(x / y)

def complex_calculation():
  with Result:
    a &lt;- safe_div(10, 2)
    b &lt;- safe_div(a, 3)
    c &lt;- safe_div(b, 2)
    return wrap(c * 2)
</code></pre>
<p>Neste exemplo:</p>
<ol>
<li>Definimos o tipo <code>Result</code> e suas funções <code>bind</code> e <code>wrap</code>.</li>
<li><code>safe_div</code> é uma função que retorna um <code>Result</code>.</li>
<li><code>complex_calculation</code> usa um bloco <code>with</code> para encadear operações de <code>safe_div</code>.</li>
</ol>
<h2 id="vantagens-dos-blocos-with"><a class="header" href="#vantagens-dos-blocos-with">Vantagens dos Blocos <code>with</code></a></h2>
<ol>
<li><strong>Clareza</strong>: Torna o código mais legível ao lidar com sequências de operações monádicas.</li>
<li><strong>Controle de Fluxo</strong>: Facilita o tratamento de erros e casos excepcionais.</li>
<li><strong>Composição</strong>: Permite compor operações complexas a partir de operações mais simples.</li>
<li><strong>Abstração</strong>: Esconde a complexidade da manipulação monádica.</li>
</ol>
<h2 id="aplicações-práticas-1"><a class="header" href="#aplicações-práticas-1">Aplicações Práticas</a></h2>
<h3 id="tratamento-de-erros"><a class="header" href="#tratamento-de-erros">Tratamento de Erros</a></h3>
<pre><code class="language-bend">def process_user_input():
  with Result:
    input &lt;- read_user_input()
    validated &lt;- validate_input(input)
    processed &lt;- process_data(validated)
    return wrap(processed)
</code></pre>
<h3 id="operações-de-io"><a class="header" href="#operações-de-io">Operações de I/O</a></h3>
<pre><code class="language-bend">def read_and_process_file(path):
  with IO:
    content &lt;- IO/read_file(path)
    processed &lt;- process_content(content)
    * &lt;- IO/write_file("output.txt", processed)
    return wrap(())
</code></pre>
<h3 id="computações-assíncronas"><a class="header" href="#computações-assíncronas">Computações Assíncronas</a></h3>
<pre><code class="language-bend">def fetch_and_process_data():
  with Async:
    data &lt;- fetch_data_from_api()
    processed &lt;- process_data(data)
    * &lt;- save_to_database(processed)
    return wrap(processed)
</code></pre>
<h2 id="considerações-avançadas-1"><a class="header" href="#considerações-avançadas-1">Considerações Avançadas</a></h2>
<ol>
<li><strong>Composição de Mônadas</strong>: Em sistemas mais complexos, pode ser necessário compor diferentes tipos de mônadas.</li>
<li><strong>Desempenho</strong>: O uso excessivo de operações monádicas pode impactar o desempenho em alguns casos.</li>
<li><strong>Debugging</strong>: Depurar código monádico pode ser mais desafiador, exigindo ferramentas e técnicas específicas.</li>
</ol>
<h2 id="conclusão-1"><a class="header" href="#conclusão-1">Conclusão</a></h2>
<p>Os blocos <code>with</code> em Bend oferecem uma maneira elegante e poderosa de trabalhar com computações monádicas. Eles permitem escrever código mais limpo e seguro, especialmente ao lidar com operações que podem falhar ou ter efeitos colaterais. Ao entender e utilizar efetivamente os blocos <code>with</code>, os programadores podem criar sistemas mais robustos e fáceis de manter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-em-bend"><a class="header" href="#io-em-bend">IO em Bend</a></h1>
<h2 id="introdução-2"><a class="header" href="#introdução-2">Introdução</a></h2>
<p>Em Bend, a construção <code>IO</code> é usada para lidar com operações de entrada e saída (I/O) de forma declarativa e funcional. Este guia detalha a implementação e uso do <code>IO</code> em Bend, explicando cada componente e como eles se combinam para realizar operações I/O de maneira segura e eficiente.</p>
<h2 id="tipo-io"><a class="header" href="#tipo-io">Tipo <code>IO</code></a></h2>
<p>O tipo <code>IO</code> em Bend é usado para encapsular operações de entrada e saída. Ele possui duas variantes principais:</p>
<ol>
<li><strong><code>IO/Done</code></strong>: Representa uma operação I/O que foi concluída com sucesso.</li>
<li><strong><code>IO/Call</code></strong>: Representa uma chamada I/O pendente que inclui a função a ser chamada, seus argumentos e um continuador (<code>cont</code>) para processar o resultado.</li>
</ol>
<h3 id="definição"><a class="header" href="#definição">Definição</a></h3>
<pre><code class="language-bend">type IO:
  Done { magic, expr }
  Call { magic, func, argm, cont }
</code></pre>
<ul>
<li><strong><code>magic</code></strong>: Um valor especial usado para verificar a validade da operação.</li>
<li><strong><code>expr</code></strong>: O resultado da operação.</li>
<li><strong><code>func</code></strong>: A função a ser chamada para a operação I/O.</li>
<li><strong><code>argm</code></strong>: Os argumentos para a função.</li>
<li><strong><code>cont</code></strong>: Um continuador, que é uma função a ser chamada com o resultado da operação.</li>
</ul>
<h2 id="funções-básicas-de-io"><a class="header" href="#funções-básicas-de-io">Funções Básicas de IO</a></h2>
<h3 id="iomagic"><a class="header" href="#iomagic"><code>IO/MAGIC</code></a></h3>
<p>Esta função retorna um par de valores mágicos que são usados para verificar a validade de operações I/O. Esses valores são utilizados internamente para garantir que as operações I/O sejam tratadas corretamente.</p>
<pre><code class="language-bend">def IO/MAGIC:
  return (0xD0CA11, 0xFF1FF1)
</code></pre>
<h3 id="iowrap"><a class="header" href="#iowrap"><code>IO/wrap</code></a></h3>
<p>Encapsula um valor em um <code>IO/Done</code>, indicando que a operação foi concluída com sucesso.</p>
<pre><code class="language-bend">def IO/wrap(x):
  return IO/Done(IO/MAGIC, x)
</code></pre>
<h3 id="iobind"><a class="header" href="#iobind"><code>IO/bind</code></a></h3>
<p>Combina duas operações I/O, executando a segunda operação após a conclusão da primeira.</p>
<pre><code class="language-bend">def IO/bind(a, b):
  match a:
    case IO/Done:
      b = undefer(b)
      return b(a.expr)
    case IO/Call:
      return IO/Call(IO/MAGIC, a.func, a.argm, lambda x: IO/bind(a.cont(x), b))
</code></pre>
<ul>
<li><strong><code>a</code></strong>: A primeira operação I/O.</li>
<li><strong><code>b</code></strong>: A segunda operação I/O.</li>
<li>Se <code>a</code> é <code>IO/Done</code>, a segunda operação <code>b</code> é executada com o resultado de <code>a</code>.</li>
<li>Se <code>a</code> é <code>IO/Call</code>, uma nova chamada I/O é criada, encadeando <code>a</code> e <code>b</code>.</li>
</ul>
<h3 id="call"><a class="header" href="#call"><code>call</code></a></h3>
<p>Cria uma operação I/O pendente.</p>
<pre><code class="language-bend">def call(func, argm):
  return IO/Call(IO/MAGIC, func, argm, lambda x: IO/Done(IO/MAGIC, x))
</code></pre>
<h2 id="conclusão-2"><a class="header" href="#conclusão-2">Conclusão</a></h2>
<p>Este guia apresentou a implementação e o uso do <code>IO</code> em Bend, abordando desde funções básicas até operações de arquivo e utilitários de entrada e saída. Com esses conhecimentos, você pode realizar operações I/O de forma segura e eficiente em seus programas Bend.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-e-output-em-bend"><a class="header" href="#input-e-output-em-bend">Input e Output em Bend</a></h1>
<h2 id="introdução-3"><a class="header" href="#introdução-3">Introdução</a></h2>
<p>As operações de Input e Output (I/O) são fundamentais em qualquer linguagem de programação. Em Bend, essas operações são tratadas de forma segura e controlada, seguindo o paradigma de programação funcional.</p>
<h2 id="conceitos-fundamentais"><a class="header" href="#conceitos-fundamentais">Conceitos Fundamentais</a></h2>
<h3 id="efeitos-colaterais-e-pureza"><a class="header" href="#efeitos-colaterais-e-pureza">Efeitos Colaterais e Pureza</a></h3>
<p>Em programação funcional, as funções puras são aquelas que sempre produzem o mesmo resultado para os mesmos argumentos, sem efeitos colaterais. No entanto, operações de I/O são inerentemente impuras, pois interagem com o mundo externo.</p>
<p>Bend resolve este paradoxo encapsulando operações de I/O em um tipo especial <code>IO</code>, que representa computações que podem ter efeitos colaterais.</p>
<h3 id="o-tipo-io"><a class="header" href="#o-tipo-io">O Tipo <code>IO</code></a></h3>
<p>O tipo <code>IO</code> em Bend é uma mônada que encapsula operações impuras. Isso permite que o sistema de tipos diferencie entre computações puras e impuras, mantendo a integridade do programa.</p>
<h2 id="operações-básicas-de-io"><a class="header" href="#operações-básicas-de-io">Operações Básicas de I/O</a></h2>
<h3 id="impressão-ioprint"><a class="header" href="#impressão-ioprint">Impressão (<code>IO/print</code>)</a></h3>
<p>A função <code>IO/print</code> é usada para exibir texto na saída padrão.</p>
<pre><code class="language-bend">def IO/print(text):
  # Implementação interna
</code></pre>
<p>Esta função converte a string de entrada em bytes UTF-8 e os escreve no descritor de arquivo padrão de saída.</p>
<h3 id="entrada-ioinput"><a class="header" href="#entrada-ioinput">Entrada (<code>IO/input</code>)</a></h3>
<p>A função <code>IO/input</code> lê uma linha de texto da entrada padrão.</p>
<pre><code class="language-bend">def IO/input():
  # Implementação interna
</code></pre>
<p>Esta implementação lê bytes um por um até encontrar um caractere de nova linha, acumulando-os e depois decodificando-os como UTF-8.</p>
<h2 id="operações-de-arquivo"><a class="header" href="#operações-de-arquivo">Operações de Arquivo</a></h2>
<p>Bend fornece um conjunto de funções para manipulação de arquivos, incluindo:</p>
<ul>
<li><code>IO/FS/open</code>: Abre um arquivo</li>
<li><code>IO/FS/close</code>: Fecha um arquivo</li>
<li><code>IO/FS/read</code>: Lê bytes de um arquivo</li>
<li><code>IO/FS/write</code>: Escreve bytes em um arquivo</li>
<li><code>IO/FS/seek</code>: Move o ponteiro de leitura/escrita em um arquivo</li>
</ul>
<h3 id="exemplo-escrita-em-arquivo"><a class="header" href="#exemplo-escrita-em-arquivo">Exemplo: Escrita em Arquivo</a></h3>
<pre><code class="language-bend">def write_to_file():
  with IO:
    fp &lt;- IO/FS/open("testing.txt", "w")
    input &lt;- read_input()
    * &lt;- IO/FS/write(fp, String/encode_utf8(input))
    * &lt;- IO/FS/write(fp, String/encode_utf8("\n"))
    return IO/FS/close(fp)
</code></pre>
<p>Este exemplo demonstra como abrir um arquivo, escrever dados nele e fechá-lo corretamente.</p>
<h2 id="gerenciamento-de-recursos"><a class="header" href="#gerenciamento-de-recursos">Gerenciamento de Recursos</a></h2>
<p>Em Bend, é importante gerenciar recursos como descritores de arquivo corretamente. O uso do padrão <code>with IO:</code> ajuda a garantir que as operações de I/O sejam realizadas de forma segura e que os recursos sejam liberados adequadamente.</p>
<h2 id="tratamento-de-erros-1"><a class="header" href="#tratamento-de-erros-1">Tratamento de Erros</a></h2>
<p>Operações de I/O são propensas a erros (por exemplo, arquivo não encontrado, permissões insuficientes). Em Bend, esses erros são tipicamente representados usando tipos de resultado, permitindo um tratamento de erros robusto e explícito.</p>
<h2 id="considerações-de-desempenho"><a class="header" href="#considerações-de-desempenho">Considerações de Desempenho</a></h2>
<p>Ao trabalhar com I/O, especialmente com arquivos grandes, é importante considerar o desempenho. Operações de leitura e escrita em blocos maiores geralmente são mais eficientes do que operações byte a byte.</p>
<h2 id="conclusão-3"><a class="header" href="#conclusão-3">Conclusão</a></h2>
<p>As operações de I/O em Bend são projetadas para serem seguras, expressivas e alinhadas com os princípios da programação funcional. Ao encapsular efeitos colaterais no tipo <code>IO</code>, Bend permite que os programadores escrevam código que interage com o mundo externo de maneira controlada e previsível.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manipulação-de-tempo-em-bend"><a class="header" href="#manipulação-de-tempo-em-bend">Manipulação de Tempo em Bend</a></h1>
<h2 id="introdução-4"><a class="header" href="#introdução-4">Introdução</a></h2>
<p>A manipulação precisa do tempo é crucial em muitas aplicações, desde medição de desempenho até agendamento de tarefas. Bend oferece funções para obter o tempo atual e controlar o fluxo de execução do programa através de atrasos.</p>
<h2 id="conceitos-fundamentais-1"><a class="header" href="#conceitos-fundamentais-1">Conceitos Fundamentais</a></h2>
<h3 id="tempo-monotônico"><a class="header" href="#tempo-monotônico">Tempo Monotônico</a></h3>
<p>Bend utiliza um relógio monotônico para medições de tempo. Um relógio monotônico garante que o tempo sempre avança, mesmo se o relógio do sistema for ajustado. Isso é crucial para medições precisas de intervalos de tempo.</p>
<h3 id="resolução-de-nanosegundos"><a class="header" href="#resolução-de-nanosegundos">Resolução de Nanosegundos</a></h3>
<p>As funções de tempo em Bend operam com resolução de nanosegundos, permitindo medições de alta precisão.</p>
<h2 id="funções-principais"><a class="header" href="#funções-principais">Funções Principais</a></h2>
<h3 id="ioget_time"><a class="header" href="#ioget_time"><code>IO/get_time</code></a></h3>
<p>Esta função retorna o timestamp atual em nanosegundos.</p>
<pre><code class="language-bend">IO/get_time(): 
  # Implementação interna
</code></pre>
<h4 id="uso"><a class="header" href="#uso">Uso</a></h4>
<ul>
<li>Medir intervalos de tempo</li>
<li>Obter timestamps para logging</li>
<li>Sincronização de eventos</li>
</ul>
<h3 id="iosleep"><a class="header" href="#iosleep"><code>IO/sleep</code></a></h3>
<p>Esta função suspende a execução do programa por um número especificado de segundos.</p>
<pre><code class="language-bend">def IO/sleep(seconds):
  # Implementação interna
</code></pre>
<h4 id="uso-1"><a class="header" href="#uso-1">Uso</a></h4>
<ul>
<li>Criar atrasos em programas</li>
<li>Implementar temporizadores</li>
<li>Controlar a taxa de execução de loops</li>
</ul>
<h2 id="considerações-teóricas"><a class="header" href="#considerações-teóricas">Considerações Teóricas</a></h2>
<h3 id="precisão-vs-exatidão"><a class="header" href="#precisão-vs-exatidão">Precisão vs. Exatidão</a></h3>
<p>É importante entender a diferença entre precisão e exatidão ao trabalhar com tempo:</p>
<ul>
<li>Precisão refere-se à resolução das medições (nanosegundos em Bend).</li>
<li>Exatidão refere-se a quão próximo o tempo medido está do tempo real.</li>
</ul>
<p>Bend oferece alta precisão, mas a exatidão pode variar dependendo do hardware e do sistema operacional.</p>
<h3 id="efeitos-da-sobrecarga-do-sistema"><a class="header" href="#efeitos-da-sobrecarga-do-sistema">Efeitos da Sobrecarga do Sistema</a></h3>
<p>Funções como <code>IO/sleep</code> podem não garantir um atraso exato devido à sobrecarga do sistema e ao escalonamento de processos. Sempre considere uma margem de erro em aplicações sensíveis ao tempo.</p>
<h2 id="padrões-de-uso-e-melhores-práticas"><a class="header" href="#padrões-de-uso-e-melhores-práticas">Padrões de Uso e Melhores Práticas</a></h2>
<h3 id="medição-de-desempenho"><a class="header" href="#medição-de-desempenho">Medição de Desempenho</a></h3>
<pre><code class="language-bend">def measure_execution_time(operation):
  with IO:
    start_time &lt;- IO/get_time()
    result &lt;- operation()
    end_time &lt;- IO/get_time()
    execution_time = (end_time - start_time) / 1_000_000_000.0
    * &lt;- IO/print("Tempo de execução: " + String/from_number(execution_time) + " segundos\n")
    return IO/wrap(result)
</code></pre>
<p>Este padrão é útil para profiling e otimização de código.</p>
<h3 id="temporizadores"><a class="header" href="#temporizadores">Temporizadores</a></h3>
<pre><code class="language-bend">def simple_timer(seconds):
  with IO:
    * &lt;- IO/print("Iniciando temporizador de " + String/from_number(seconds) + " segundos...\n")
    * &lt;- IO/sleep(seconds)
    * &lt;- IO/print("Temporizador concluído!\n")
    return IO/wrap(())
</code></pre>
<p>Útil para criar atrasos controlados ou simular operações que levam tempo.</p>
<h3 id="ações-periódicas"><a class="header" href="#ações-periódicas">Ações Periódicas</a></h3>
<pre><code class="language-bend">def repeat_action(action, interval, count):
  with IO:
    if count &gt; 0:
      * &lt;- action()
      * &lt;- IO/sleep(interval)
      return repeat_action(action, interval, count - 1)
    else:
      return IO/wrap(())
</code></pre>
<p>Este padrão é valioso para tarefas que precisam ser executadas em intervalos regulares.</p>
<h2 id="considerações-avançadas-2"><a class="header" href="#considerações-avançadas-2">Considerações Avançadas</a></h2>
<h3 id="drift-temporal"><a class="header" href="#drift-temporal">Drift Temporal</a></h3>
<p>Em operações de longa duração ou repetitivas, pode ocorrer um acúmulo de pequenos erros de tempo (drift). Para aplicações críticas, considere recalibrar periodicamente com base no tempo absoluto.</p>
<h3 id="concorrência-e-tempo"><a class="header" href="#concorrência-e-tempo">Concorrência e Tempo</a></h3>
<p>Em ambientes concorrentes, o comportamento das funções de tempo pode ser afetado. Sempre considere o impacto da concorrência ao projetar sistemas sensíveis ao tempo.</p>
<h2 id="conclusão-4"><a class="header" href="#conclusão-4">Conclusão</a></h2>
<p>As funções de manipulação de tempo em Bend oferecem ferramentas poderosas para medir e controlar o fluxo temporal em programas. Ao compreender os conceitos subjacentes e as melhores práticas, os desenvolvedores podem criar aplicações robustas e eficientes que lidam adequadamente com aspectos temporais.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operações-com-arquivos-em-bend"><a class="header" href="#operações-com-arquivos-em-bend">Operações com Arquivos em Bend</a></h1>
<h2 id="introdução-5"><a class="header" href="#introdução-5">Introdução</a></h2>
<p>As operações com arquivos são uma parte fundamental da programação, permitindo a persistência de dados e a comunicação entre diferentes partes de um sistema. Em Bend, essas operações são tratadas de forma segura e funcional, mantendo a integridade do sistema de tipos e o controle sobre efeitos colaterais.</p>
<h2 id="conceitos-fundamentais-2"><a class="header" href="#conceitos-fundamentais-2">Conceitos Fundamentais</a></h2>
<h3 id="descritores-de-arquivo"><a class="header" href="#descritores-de-arquivo">Descritores de Arquivo</a></h3>
<p>Em Bend, os arquivos são manipulados através de descritores de arquivo, que são identificadores únicos representados como valores <code>U24</code>. Estes descritores são abstrações que permitem o acesso controlado aos recursos do sistema de arquivos.</p>
<h3 id="modos-de-abertura-de-arquivo"><a class="header" href="#modos-de-abertura-de-arquivo">Modos de Abertura de Arquivo</a></h3>
<p>Bend suporta vários modos de abertura de arquivo, cada um com um propósito específico:</p>
<ul>
<li><code>"r"</code>: Leitura</li>
<li><code>"w"</code>: Escrita (sobrescreve o conteúdo existente)</li>
<li><code>"a"</code>: Append (adiciona ao final do arquivo)</li>
<li><code>"r+"</code>: Leitura e escrita</li>
<li><code>"w+"</code>: Leitura e escrita (sobrescreve o conteúdo existente)</li>
<li><code>"a+"</code>: Leitura e append</li>
</ul>
<h3 id="streams-padrão"><a class="header" href="#streams-padrão">Streams Padrão</a></h3>
<p>Bend fornece acesso aos streams padrão do sistema operacional:</p>
<ul>
<li><code>IO/FS/STDIN (0)</code>: Entrada padrão</li>
<li><code>IO/FS/STDOUT (1)</code>: Saída padrão</li>
<li><code>IO/FS/STDERR (2)</code>: Erro padrão</li>
</ul>
<h2 id="operações-principais"><a class="header" href="#operações-principais">Operações Principais</a></h2>
<h3 id="abertura-e-fechamento-de-arquivos"><a class="header" href="#abertura-e-fechamento-de-arquivos">Abertura e Fechamento de Arquivos</a></h3>
<pre><code class="language-bend">def IO/FS/open(path, mode):
    # Implementação interna

def IO/FS/close(file):
    # Implementação interna
</code></pre>
<p>Estas funções são cruciais para gerenciar recursos do sistema de arquivos. É importante sempre fechar os arquivos após o uso para evitar vazamentos de recursos.</p>
<h3 id="leitura-de-arquivos"><a class="header" href="#leitura-de-arquivos">Leitura de Arquivos</a></h3>
<p>Bend oferece várias funções para leitura de arquivos:</p>
<pre><code class="language-bend">def IO/FS/read(file, num_bytes):
    # Implementação interna

def IO/FS/read_line(file):
    # Implementação interna

def IO/FS/read_until_end(file):
    # Implementação interna

def IO/FS/read_file(path):
    # Implementação interna
</code></pre>
<p>Estas funções permitem diferentes estratégias de leitura, desde ler um número específico de bytes até ler o arquivo inteiro.</p>
<h3 id="escrita-em-arquivos"><a class="header" href="#escrita-em-arquivos">Escrita em Arquivos</a></h3>
<pre><code class="language-bend">def IO/FS/write(file, bytes):
    # Implementação interna

def IO/FS/write_file(path, bytes):
    # Implementação interna
</code></pre>
<p>Estas funções permitem escrever dados em arquivos, seja em um arquivo já aberto ou criando um novo arquivo.</p>
<h3 id="posicionamento-no-arquivo"><a class="header" href="#posicionamento-no-arquivo">Posicionamento no Arquivo</a></h3>
<pre><code class="language-bend">def IO/FS/seek(file, offset, mode):
    # Implementação interna
</code></pre>
<p>A função <code>seek</code> permite mover o ponteiro de leitura/escrita dentro do arquivo, facilitando operações em posições específicas.</p>
<h2 id="considerações-teóricas-1"><a class="header" href="#considerações-teóricas-1">Considerações Teóricas</a></h2>
<h3 id="efeitos-colaterais-e-pureza-funcional"><a class="header" href="#efeitos-colaterais-e-pureza-funcional">Efeitos Colaterais e Pureza Funcional</a></h3>
<p>Operações de arquivo são inerentemente impuras, pois modificam o estado do sistema. Bend lida com isso encapsulando essas operações no tipo <code>IO</code>, mantendo a pureza funcional do restante do código.</p>
<h3 id="buffering-e-performance"><a class="header" href="#buffering-e-performance">Buffering e Performance</a></h3>
<p>As operações de leitura e escrita em Bend são geralmente bufferizadas para melhorar a performance. Isso significa que as operações podem não ser imediatamente refletidas no sistema de arquivos.</p>
<h3 id="concorrência-e-acesso-a-arquivos"><a class="header" href="#concorrência-e-acesso-a-arquivos">Concorrência e Acesso a Arquivos</a></h3>
<p>Ao trabalhar com arquivos em ambientes concorrentes, é importante considerar questões de sincronização para evitar condições de corrida e corrupção de dados.</p>
<h2 id="padrões-de-uso-e-melhores-práticas-1"><a class="header" href="#padrões-de-uso-e-melhores-práticas-1">Padrões de Uso e Melhores Práticas</a></h2>
<h3 id="leitura-segura-de-arquivos"><a class="header" href="#leitura-segura-de-arquivos">Leitura Segura de Arquivos</a></h3>
<pre><code class="language-bend">def safe_read_file(path):
  with IO:
    result &lt;- IO/try(lambda: IO/FS/read_file(path))
    match result:
      case Result/Ok:
        return IO/wrap(result.val)
      case Result/Err:
        * &lt;- IO/print("Erro ao ler o arquivo: " + result.err + "\n")
        return IO/wrap([])
</code></pre>
<p>Este padrão demonstra como lidar com possíveis erros ao ler arquivos.</p>
<h3 id="escrita-atômica"><a class="header" href="#escrita-atômica">Escrita Atômica</a></h3>
<pre><code class="language-bend">def atomic_write(path, content):
  with IO:
    temp_path = path + ".tmp"
    * &lt;- IO/FS/write_file(temp_path, content)
    * &lt;- IO/FS/rename(temp_path, path)
    return IO/wrap(())
</code></pre>
<p>Este padrão garante que a escrita em um arquivo seja atômica, evitando estados intermediários inconsistentes.</p>
<h3 id="processamento-de-arquivos-grandes"><a class="header" href="#processamento-de-arquivos-grandes">Processamento de Arquivos Grandes</a></h3>
<pre><code class="language-bend">def process_large_file(path, process_chunk):
  with IO:
    fd &lt;- IO/FS/open(path, "r")
    * &lt;- process_chunks(fd, process_chunk)
    * &lt;- IO/FS/close(fd)
    return IO/wrap(())

def process_chunks(fd, process_chunk):
  with IO:
    chunk &lt;- IO/FS/read(fd, 1024)
    match chunk:
      case List/Nil:
        return IO/wrap(())
      case List/Cons:
        * &lt;- process_chunk(chunk)
        return process_chunks(fd, process_chunk)
</code></pre>
<p>Este padrão demonstra como processar arquivos grandes em chunks, evitando carregar todo o conteúdo na memória.</p>
<h2 id="considerações-avançadas-3"><a class="header" href="#considerações-avançadas-3">Considerações Avançadas</a></h2>
<h3 id="tratamento-de-erros-2"><a class="header" href="#tratamento-de-erros-2">Tratamento de Erros</a></h3>
<p>É crucial implementar tratamento de erros robusto ao trabalhar com arquivos, considerando cenários como arquivos não encontrados, permissões insuficientes, e erros de I/O.</p>
<h3 id="portabilidade"><a class="header" href="#portabilidade">Portabilidade</a></h3>
<p>Ao escrever código que manipula arquivos, considere as diferenças entre sistemas operacionais, como separadores de caminho e codificações de caracteres.</p>
<h3 id="segurança"><a class="header" href="#segurança">Segurança</a></h3>
<p>Sempre valide e sanitize caminhos de arquivo e conteúdos para prevenir vulnerabilidades de segurança, como injeção de caminho.</p>
<h2 id="conclusão-5"><a class="header" href="#conclusão-5">Conclusão</a></h2>
<p>As operações com arquivos em Bend oferecem um conjunto poderoso e flexível de ferramentas para manipulação de dados persistentes. Ao compreender os conceitos subjacentes e seguir as melhores práticas, os desenvolvedores podem criar aplicações robustas e eficientes que interagem de forma segura com o sistema de arquivos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equational-notation-in-bend"><a class="header" href="#equational-notation-in-bend">Equational Notation in Bend</a></h1>
<p>Bend is a language that allows equational notation similar to Haskell, but with simpler and more straightforward syntax.</p>
<p>This notation is very useful for defining mathematical and recursive functions, as it allows for a clear and concise representation.</p>
<p>Equational notation in Bend is a powerful tool for defining mathematical and recursive functions, which can be used to solve a wide variety of problems simply and efficiently. This is ideal for those who seek to utilize functional programming.</p>
<h2 id="how-to-write-functions-in-equational-notation"><a class="header" href="#how-to-write-functions-in-equational-notation">How to Write Functions in Equational Notation</a></h2>
<h3 id="basic-structure-1"><a class="header" href="#basic-structure-1">Basic Structure</a></h3>
<p>The equational notation in Bend follows a simple structure:</p>
<p><code>Function parameters = expression</code></p>
<ul>
<li><code>Function</code> is the name of the function.</li>
<li><code>parameters</code> are the parameters that the function receives.</li>
<li><code>expression</code> is the result or operation that the function should perform.</li>
</ul>
<h3 id="simple-examples"><a class="header" href="#simple-examples">Simple Examples</a></h3>
<h4 id="sum-function"><a class="header" href="#sum-function">Sum Function</a></h4>
<p>Let's create a function that calculates the sum from 0 to n:</p>
<pre><code class="language-py">Sum 0 = 0
Sum n = (+ n (Sum (- n 1)))
</code></pre>
<ul>
<li><code>Sum 0 = 0</code> defines that the sum of 0 is 0.</li>
<li><code>Sum n = (+ n (Sum (- n 1)))</code> defines that the sum of <code>n</code> is <code>n</code> plus the sum of <code>n-1</code>.</li>
</ul>
<h4 id="factorial-function"><a class="header" href="#factorial-function">Factorial Function</a></h4>
<p>A function to calculate the factorial of a number:</p>
<pre><code class="language-py">Factorial 0 = 1
Factorial n = (* n (Factorial (- n 1)))
</code></pre>
<ul>
<li><code>Factorial 0 = 1</code> defines that the factorial of 0 is 1.</li>
<li><code>Factorial n = (* n (Factorial (- n 1)))</code> defines that the factorial of <code>n</code> is <code>n</code> times the factorial of <code>n-1</code>.</li>
</ul>
<h4 id="fibonacci-function"><a class="header" href="#fibonacci-function">Fibonacci Function</a></h4>
<p>A function to calculate the nth Fibonacci number:</p>
<pre><code class="language-py">Fibonacci 0 = 0
Fibonacci 1 = 1
Fibonacci n = (+ (Fibonacci (- n 1)) (Fibonacci (- n 2)))
</code></pre>
<ul>
<li><code>Fibonacci 0 = 0</code> defines that the 0th Fibonacci number is 0.</li>
<li><code>Fibonacci 1 = 1</code> defines that the 1st Fibonacci number is 1.</li>
<li><code>Fibonacci n = (+ (Fibonacci (- n 1)) (Fibonacci (- n 2)))</code> defines that the nth Fibonacci number is the sum of the two preceding ones.</li>
</ul>
<h3 id="using-user-defined-types"><a class="header" href="#using-user-defined-types">Using User-Defined Types</a></h3>
<p>Equational notation can also be used with user-defined types, such as lists, trees, etc.</p>
<h4 id="defining-a-list"><a class="header" href="#defining-a-list">Defining a List</a></h4>
<p>First, let's define a <code>UserList</code> type that represents a list:</p>
<pre><code class="language-rs">type UserList:
  Cons { head, ~tail }
  Nil
</code></pre>
<ul>
<li><code>Cons</code> is a constructor that has a <code>head</code> and a <code>tail</code>.</li>
<li><code>Nil</code> represents an empty list.</li>
</ul>
<h4 id="length-function-for-a-list"><a class="header" href="#length-function-for-a-list">Length Function for a List</a></h4>
<p>Now, a function that calculates the length of a list:</p>
<pre><code class="language-py">Length UserList/Nil = 0
Length (UserList/Cons head tail) = (+ 1 (Length tail))
</code></pre>
<ul>
<li><code>Length UserList/Nil = 0</code> defines that the length of an empty list is 0.</li>
<li><code>Length (UserList/Cons head tail) = (+ 1 (Length tail))</code> defines that the length of a non-empty list is 1 plus the length of the <code>tail</code>.</li>
</ul>
<h3 id="using-bend-in-equational-notation"><a class="header" href="#using-bend-in-equational-notation">Using Bend in Equational Notation</a></h3>
<p>Creating a function that calculates <code>2^n</code> using the <code>py</code> in traditional notation:</p>
<pre><code class="language-py">def exp2(n):
  bend x = 0:
    when x &lt; n:
      lft = fork(x + 1)
      rgt = fork(x + 1)
      y = lft + rgt
    else:
      y = 1
  return y
</code></pre>
<p>In this example, the <code>exp2</code> function calculates <code>2^n</code> by creating a recursive tree. If <code>n</code> is 0, the function returns 1; otherwise, the function creates two branches and sums the results recursively.</p>
<p>Graphical representation of the tree created by the <code>exp2</code> function for n = 3:</p>
<pre><code class="language-md">x = 0                 [ ]
                     /   \
                    /     \
                   /       \
                  /         \
                 /           \
                /             \
x = 1          [ ]             [ ]
              /  \            /  \
             /    \          /    \
            /      \        /      \
x = 2      [ ]     [ ]     [ ]     [ ]
           / \    /  \     / \    /  \
x = 3    [1] [1] [1] [1] [1] [1] [1] [1]
</code></pre>
<p>At the end, each leaf gets the value 1 and the sum of all the leaves is <code>2^n</code>.</p>
<p>It is possible to use this notation while using the equational one, but for standardization, there is an equivalent way to write the <code>exp2</code> function using equational notation:</p>
<pre><code class="language-py">Exp2 n =
  (bend x = 0 {
    when (&lt; x n):(
      let lft = (fork (+ x 1))
      let rgt = (fork (+ x 1))
      let y = (+ lft rgt)
      y)
    else:
      let y = 1
      y
  })
</code></pre>
<p>The <code>Exp2</code> function is equivalent to the <code>exp2</code> function and uses equational notation to define the function clearly and concisely.</p>
<p>The syntax of <code>py</code> in equational notation is as follows:
bend bind=term, ... { when cond: term; else: term; }</p>
<p>Complete Example
Let's combine everything in a complete example:</p>
<pre><code class="language-py">Main =
  let sum      = ("Sum", (Sum 5))
  let factorial  = ("Factorial", (Factorial 5))
  let fibonacci = ("Fibonacci", (Fibonacci 6))
  let list      = (UserList/Cons ("sum", sum)
                  (UserList/Cons ("factorial", factorial)
                  (UserList/Cons ("fibonacci", fibonacci)
                  UserList/Nil)))
  let length    = ("Length original List", (Length list))
  let exp2a     = ("exp2: ", (exp2(10)))
  let exp2b     = ("Exp2: ", (Exp2 10))
  let result    = [sum, factorial, fibonacci, length, exp2a, exp2b]
  result
</code></pre>
<p>This example:</p>
<ul>
<li>Defines and uses sum, factorial, and Fibonacci functions.</li>
<li>Creates a list with the results.</li>
<li>Calculates the length of the list.</li>
<li>Calculates <code>2^n</code> in two different ways.</li>
<li>Creates a new list with the previous results.</li>
<li>Returns the new list.</li>
</ul>
<h3 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h3>
<p>Equational notation in Bend makes it easier to define mathematical and recursive functions clearly and concisely. This makes Bend a powerful language for solving a wide variety of problems using functional programming.</p>
<p>Understanding and using this notation can significantly improve the clarity and efficiency of your code, especially when dealing with mathematical and recursive problems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-calculus-in-bend"><a class="header" href="#lambda-calculus-in-bend">Lambda Calculus in Bend</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Bend allows the use of lambdas, adopting notations like Scott and Church, with a syntax similar to the equational notation we saw earlier.</p>
<h3 id="defining-data-types"><a class="header" href="#defining-data-types">Defining Data Types</a></h3>
<h4 id="booleans"><a class="header" href="#booleans">Booleans</a></h4>
<p>To define data types using lambdas, we use the assignment notation.
For example, to define the boolean values <code>false</code> and <code>true</code>, we use:</p>
<pre><code class="language-js">false = λf λt f
true  = λf λt t
</code></pre>
<p>Alternatively, you can use <code>@</code> in place of <code>λ</code>:</p>
<pre><code class="language-js">false = @f @t f
true  = @f @t t
</code></pre>
<ul>
<li><code>false</code> is a function that takes two arguments and returns the first.</li>
<li><code>true</code> is a function that takes two arguments and returns the second.</li>
</ul>
<p>Examples of Using Booleans</p>
<p>Defining the <code>not</code> Function
To define the <code>not</code> function using booleans defined by lambdas:</p>
<pre><code class="language-js">not = λb (b true false)
</code></pre>
<ul>
<li><code>not</code> is a function that takes a boolean <code>b</code> and returns <code>true</code> if <code>b</code> is <code>false</code>
and <code>false</code> if <code>b</code> is <code>true</code>.</li>
</ul>
<h4 id="defining-natural-numbers"><a class="header" href="#defining-natural-numbers">Defining Natural Numbers</a></h4>
<h5 id="scott-encoded-natural-numbers"><a class="header" href="#scott-encoded-natural-numbers">Scott-Encoded Natural Numbers</a></h5>
<p>To define natural numbers using Scott encoding:</p>
<pre><code class="language-js">Zs =    λz λs z
Ss = λp λz λs (s p)
</code></pre>
<p>Scott encoding represents natural numbers using a case-based approach.
Each number is a function that takes two arguments:</p>
<ul>
<li>
<p>The first argument is returned if the number is zero.</p>
</li>
<li>
<p>The second argument is applied recursively if the number is a successor.</p>
</li>
<li>
<p><code>Zs</code> represents the number zero.</p>
</li>
<li>
<p><code>Ss</code> is a function that takes a Scott-encoded natural number and returns its successor.</p>
</li>
</ul>
<p>Scott encoding allows for direct deconstruction of natural numbers, making it easier to define recursive functions that operate on these numbers.</p>
<h5 id="church-encoded-natural-numbers"><a class="header" href="#church-encoded-natural-numbers">Church-Encoded Natural Numbers</a></h5>
<p>To define natural numbers using Church encoding:</p>
<pre><code class="language-js">Zc =    λz λs z
Sc = λp λz λs (s (p z s))
</code></pre>
<p>Church encoding represents natural numbers as functions that iterate a number of times over a process. Each number is a function that takes two arguments:</p>
<ul>
<li>
<p>The first argument is the initial value (usually zero).</p>
</li>
<li>
<p>The second argument is the function that will be applied repeatedly.</p>
</li>
<li>
<p><code>Zc</code> represents the number zero.</p>
</li>
<li>
<p><code>Sc</code> is a function that takes a Church-encoded natural number and returns its successor.</p>
</li>
</ul>
<p>Church encoding makes it easier to define arithmetic functions, such as addition and multiplication, through functional composition.</p>
<p>In summary, while Scott encoding is based on a case and deconstruction approach, Church encoding is based on repetitive application of functions, which facilitates the definition of arithmetic operations.</p>
<h5 id="examples-of-using-natural-numbers"><a class="header" href="#examples-of-using-natural-numbers">Examples of Using Natural Numbers</a></h5>
<h6 id="adding-natural-numbers"><a class="header" href="#adding-natural-numbers">Adding Natural Numbers</a></h6>
<p>To define the addition of Church-encoded natural numbers:</p>
<pre><code class="language-js">add = λm λn λz λs (m (n z s) s)
</code></pre>
<p>The addition function <code>add</code> for Church-encoded natural numbers combines the iterations of both numbers, m and n, by repeatedly applying the successor function.
Here is how it works:</p>
<ul>
<li><code>add</code> is a function that takes two Church-encoded natural numbers, m and n, and returns their sum.</li>
<li>m and n are Church-encoded natural numbers.</li>
<li>λz is the initial value (usually zero).</li>
<li>λs is the successor function that will be applied repeatedly.</li>
<li>(n z s) applies the function s n times to the initial value z.</li>
<li>m applies the function s m times to the result of (n z s), combining the iterations of both natural numbers.</li>
</ul>
<p>This results in the application of the successor function m + n times, effectively adding the two natural numbers.</p>
<p>Example Fibonacci Function</p>
<pre><code class="language-js">fib = λx switch x {
  0: 0
  1: 1
  _: (+ (fib (- x 1)) (fib (- x 2)))
}
</code></pre>
<ul>
<li><code>fib</code> is a function that calculates the nth Fibonacci number.</li>
<li><code>x</code> is the argument that determines which Fibonacci number will be calculated.</li>
<li><code>switch x { ... }</code> is a selection structure that allows different cases based on the value of <code>x</code>.</li>
<li><code>0: 0</code> defines that the 0th Fibonacci number is 0.</li>
<li><code>1: 1</code> defines that the 1st Fibonacci number is 1.</li>
<li><code>_</code> is a generic case that captures all other values of <code>x</code>.</li>
<li><code>(+ (fib (- x 1)) (fib (- x 2)))</code> recursively defines that the nth Fibonacci number is the sum of the two preceding Fibonacci numbers.</li>
</ul>
<p>This function uses recursion to calculate Fibonacci numbers efficiently, as defined by the classic mathematical sequence.</p>
<h3 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h3>
<p>Combining Everything</p>
<p>Let's combine the definitions of booleans, natural numbers, and functions in a complete example:</p>
<pre><code class="language-js">Main =
  let zero    = Zs
  let one     = (Ss Zc)
  let two     = (Ss one)
  let three   = (Ss two)
  let onec    = (Sc Zc)
  let twoc    = (Sc (Sc Zc))
  let threec  = (Sc (Sc (Sc Zc)))
  let add23   = (add twoc threec)
  let neg     = (not true)
  let exp2    = (Exp2 10)
  let sum1    = (Sum1 1 2)
  let sum2    = (Sum2 1 2)
  let fib10   = (fib 10)
  (fib10)
</code></pre>
<p>The use of the <code>hs</code> structure in lambda calculus occurs in the same way as in the equational notation seen earlier.</p>
<pre><code class="language-js">Exp2 = λn (
  bend x = 0 {
    when (&lt; x n):(
      let lft = (fork (+ x 1))
      let rgt = (fork (+ x 1))
      let y = (+ lft rgt)
      y)
    else:
      let y = 1
      y
  })

</code></pre>
<p>It is important to note that the definition of functions in lambda calculus is done similarly to the equational notation, and can be done in a mixed manner.</p>
<pre><code class="language-js">(Sum1 a b) = (+ a b)
</code></pre>
<p>and</p>
<pre><code class="language-js">Sum2 = λa λb (+ a b)
</code></pre>
<p>are examples of function definitions in lambda calculus.</p>
<p>The difference lies in how the variable to be used in the function is defined, with the first being done similarly to the equational notation and the second being purely done in lambda calculus.</p>
<h3 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h3>
<p>Lambda calculus in Bend, with support for notations like Scott and Church, provides a powerful and expressive way to define and work with functions and data types. Understanding and using this notation can significantly improve the clarity and efficiency of your code, especially when dealing with mathematical and recursive functions and data types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-scopeless-lambdas"><a class="header" href="#using-scopeless-lambdas">Using scopeless lambdas</a></h1>
<p>Scopeless lambdas are very powerful lambdas that are a side-effect of HVM's internal representation for lambda terms.</p>
<p>Scopeless lambdas are lambdas that have no scope. The variables bound by them can be used outside the lambda's body. They can be created by prefixing a dollar symbol (<code>$</code>) to a lambda's variable name.</p>
<pre><code class="language-py">id = λ$x $x # The identity function as a scopeless lambda
</code></pre>
<p>Of course, using scopeless lambdas as a replacement for regular lambdas is kind of pointless. Their real power comes from being able to use the bound variable outside the body:</p>
<pre><code class="language-js">Ex1 = (((λ$x 1) 2), $x)
</code></pre>
<p>$x gets replaced by 2 and the application ((λ$x 1) 2) gets replaced by 1
Outputs (1, 2)</p>
<p>Take some time to think about the program above. It is valid, despite <code>$x</code> being used outside the lambda's body.
However, scopeless lambdas don't bind across definitions.</p>
<pre><code class="language-js">def = $x
main = (((λ$x 1) 2), def)
</code></pre>
<p>The bound variables are local to each term.</p>
<h2 id="duplicating-scopeless-lambdas"><a class="header" href="#duplicating-scopeless-lambdas">Duplicating scopeless lambdas</a></h2>
<p>We have seen that the variable bound to a scopeless lambda gets set when the lambda is called. But, what happens if we never call <code>λ$x 1</code>? What will <code>$x</code> get set to then? Here is a program that does that:</p>
<pre><code class="language-py">Ex2 =
  let _ = λ$x 1 # Discard and erase the scopeless lambda
  (2, $x) # Outputs (2, *)
</code></pre>
<p>The program outputs <code>2</code> as the first item of the tuple, as expected.
But the second item is <code>*</code>! What is <code>*</code>?</p>
<p><code>*</code> (called ERA or eraser) is a special term HVM uses when a value was erased.
This is what happened to <code>$x</code>. We erased <code>λ$x 1</code> when we discarded it, which led to <code>$x</code> being erased.</p>
<p>What happens if we call <code>λ$x 1</code> with two different values instead?</p>
<p>Try to answer this with your knowledge of HVM.
Will it throw a runtime error?
Will it return something unexpected?</p>
<pre><code class="language-py">Ex3 =
  let f = λ$x 1 # Assign the lambda to a variable
  ((f 2), ((f 3), $x)) # Return a tuple of (f 2) and another tuple.
# Outputs (1, (1, {3 2}))
</code></pre>
<p>What? This is even more confusing. The first two values are <code>1</code>, as expected.
But what about the last term?</p>
<p>The last term in the tuple is a <strong>superposition</strong> of two values.
A superposition (see more in Dups_and_Sups.bend) is the "other side" of a duplication.
It is created here because we implicitly duplicated <code>f</code> when we used it twice,
and duplicating lambdas creates superpositions.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>Now that we know how scopeless lambdas work, we can make programs using them.
An example of a function that is usually thought as "primitive", but can be implemented using scopeless lambdas is [call/cc]
(<a href="http://www.madore.org/~david/computers/callcc.html">http://www.madore.org/~david/computers/callcc.html</a>)</p>
<p>Call/cc is a function that takes a function that takes a parameter <code>k</code>.
When <code>k</code> is called with an argument, <code>callcc</code> returns it.</p>
<pre><code class="language-py"># Function that discards its second argument
Seq a b = a

# Create a program capable of using `callcc`
CC.lang = λprogram
  let callcc  = λcallback (λ$garbage($hole) (callback λ$hole(0)));
  let result  = (program callcc);
  (Seq result $garbage)

Ex4 =
  (CC.lang λcallcc
    # This code calls `callcc`, then calls `k` to fill the hole with `42`.
    # This means that the call to callcc returns `42`, and the program returns `52`.
    # (+ (k 42) 1729) is garbage and is erased.
    (+ 10 (callcc λk(+ (k 42) 1729)))
  )

Main =
  let id2 = (id 2)
  let ex1 = Ex1
  let ex2 = Ex2
  let ex3 = Ex3
  let ex4 = Ex4
  ex4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dups-and-sups"><a class="header" href="#dups-and-sups">Dups and sups</a></h1>
<p>Term duplication is done automatically when a variable is used more than once. But it's possible to manually duplicate a term using <code>let</code>. This type of statement is called <code>dup</code> or <code>duplication</code>.</p>
<p>the number 2 in church encoding using let.</p>
<pre><code class="language-js">ch2 = λf λx let {f1 f2} = f; (f1 (f2 x))
</code></pre>
<p>the number 3 in church encoding using let.</p>
<pre><code class="language-js">ch3 = λf λx let {f0 f1} = f; let {f2 f3} = f0; (f1 (f2 (f3 x)))
</code></pre>
<p>A <code>sup</code> is a superposition of two values, it is defined using curly brackets with two terms inside.
A superposition is the opposite of a duplication.</p>
<pre><code class="language-js">sup = {3 7}
</code></pre>
<p>Sups can be used anywhere a value is expected, if anything interacts with the superposition, the result is the superposition of that interaction on both the possible values:</p>
<pre><code class="language-py">mul = λa λb (* a b)
  result     = (mul 2 5)          # returns 10
  result_sup = (mul 2 {5 7})      # returns {10 14}
  multi_sup  = (mul {2 3} {5 7})  # returns {10 21}
</code></pre>
<p>If we pair a superposition with a duplication, the result is that they behave like constructing and destructing a pair:</p>
<p>each dup variable now has a copy of the {1 2} superposition</p>
<pre><code class="language-js">let {x1 x2} = {1 2}
</code></pre>
<p>Due to how duplications are compiled, when two dups interact, they destructively interfere with each other. In this case the result doesn't follow the expected behavior (it's well defined at the HVM level, but doesn't is incorrect at a lambda-calculus level).</p>
<p>That imposes a strong restriction on correct Bend programs:
a variable should not duplicate another variable that itself duplicates some variables.</p>
<p>The program below is an example where this can go wrong when using higher-order functions.</p>
<pre><code class="language-py">def List/map(xs, f):
  fold xs:
    case List/Nil:
      return List/Nil
    case List/Cons:
      # 'f' is duplicated here
      return List/Cons(f(xs.head), List/map(xs.tail, f))
      # This line above is converted by the compiler to an explicit duplication of 'f'
      # {f1 f2} = f
      # return List/Cons(f1(xs.head), List/map(xs.tail, f2))

def main:
  # This lambda duplicates `x` and is itself duplicated by the map function.
  # This will result in wrong behavior.
  # In this specific case, the runtime will catch it and generate an error,
  # but at the moment that is not always the case.
  return List/map([1, 2, 3], lambda x: (x + x))
</code></pre>
<p>In this case, we can only have one source of duplication, or our results will be incorrect.
Either List/map is linear (doesn't duplicate <code>f</code>) or the passed function is linear (doesn't duplicate <code>x</code> or any other variable inside it).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">TODO</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
